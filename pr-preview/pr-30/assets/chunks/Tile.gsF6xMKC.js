import{Z as ye,_ as ce,$ as le,au as V,at as Ce,a6 as ae,T as F,i as Re,J as Se,R as _e,K as he,N as de,a5 as H,H as me,ak as ve}from"./XYZ.DtVLERao.js";import{z as we,aa as Ee,a2 as I,al as Ke,g as J,O as je,k as Le,i as Pe,a7 as Fe}from"./Group.BnugPW7_.js";import{C as Me}from"./Layer.CNvgX2e5.js";function W(C,e,t){if(!(t in C))return C[t]=new Set([e]),!0;const i=C[t],o=i.has(e);return o||i.add(e),!o}function ze(C,e,t){const i=C[t];return i?i.delete(e):!1}function ue(C,e){const t=C.layerStatesArray[C.layerIndex];t.extent&&(e=J(e,H(t.extent,C.viewState.projection)));const i=t.layer.getRenderSource();if(!i.getWrapX()){const o=i.getTileGridForProjection(C.viewState.projection).getExtent();o&&(e=J(e,o))}return e}class Ae extends Me{constructor(e,t){super(e),t=t||{},this.extentChanged=!0,this.renderComplete=!1,this.renderedExtent_=null,this.renderedPixelRatio,this.renderedProjection=null,this.renderedTiles=[],this.renderedSourceKey_,this.renderedSourceRevision_,this.tempExtent=we(),this.tempTileRange_=new ye(0,0,0,0),this.tempTileCoord_=ce(0,0,0);const i=t.cacheSize!==void 0?t.cacheSize:512;this.tileCache_=new le(i),this.sourceTileCache_=null,this.maxStaleKeys=i*.5}getTileCache(){return this.tileCache_}getSourceTileCache(){return this.sourceTileCache_||(this.sourceTileCache_=new le(512)),this.sourceTileCache_}getOrCreateTile(e,t,i,o){const a=this.tileCache_,r=this.getLayer().getSource(),c=V(r,r.getKey(),e,t,i);let s;if(a.containsKey(c))s=a.get(c);else{const n=o.viewState.projection,l=r.getProjection();if(s=r.getTile(e,t,i,o.pixelRatio,n,!l||Ce(l,n)?void 0:this.getSourceTileCache()),!s)return null;a.set(c,s)}return s}getTile(e,t,i,o){const a=this.getOrCreateTile(e,t,i,o);return a||null}getData(e){const t=this.frameState;if(!t)return null;const i=this.getLayer(),o=ae(t.pixelToCoordinateTransform,e.slice()),a=i.getExtent();if(a&&!Ee(a,o))return null;const u=t.viewState,r=i.getRenderSource(),c=r.getTileGridForProjection(u.projection),s=r.getTilePixelRatio(t.pixelRatio);for(let n=c.getZForResolution(u.resolution);n>=c.getMinZoom();--n){const l=c.getTileCoordForCoordAndZ(o,n),h=this.getTile(n,l[1],l[2],t);if(!h||h.getState()!==F.LOADED)continue;const g=c.getOrigin(n),p=Re(c.getTileSize(n)),w=c.getResolution(n);let d;if(h instanceof Se||h instanceof _e)d=h.getImage();else if(h instanceof he){if(d=de(h.getData()),!d)continue}else continue;const _=Math.floor(s*((o[0]-g[0])/w-l[1]*p[0])),M=Math.floor(s*((g[1]-o[1])/w-l[2]*p[1])),S=Math.round(s*r.getGutterForProjection(u.projection));return this.getImageData(d,_+S,M+S)}return null}prepareFrame(e){var o;this.renderedProjection?e.viewState.projection!==this.renderedProjection&&(this.tileCache_.clear(),this.renderedProjection=e.viewState.projection):this.renderedProjection=e.viewState.projection;const t=this.getLayer().getSource();if(!t)return!1;const i=t.getRevision();return this.renderedSourceRevision_?this.renderedSourceRevision_!==i&&(this.renderedSourceRevision_=i,this.renderedSourceKey_===t.getKey()&&(this.tileCache_.clear(),(o=this.sourceTileCache_)==null||o.clear())):this.renderedSourceRevision_=i,!0}enqueueTilesForNextExtent(){return!0}enqueueTiles(e,t,i,o,a){const u=e.viewState,r=this.getLayer(),c=r.getRenderSource(),s=c.getTileGridForProjection(u.projection),n=I(c);n in e.wantedTiles||(e.wantedTiles[n]={});const l=e.wantedTiles[n],h=r.getMapInternal(),g=Math.max(i-a,s.getMinZoom(),s.getZForResolution(Math.min(r.getMaxResolution(),h?h.getView().getResolutionForZoom(Math.max(r.getMinZoom(),0)):s.getResolution(0)),c.zDirection)),p=u.rotation,w=p?Ke(u.center,u.resolution,p,e.size):void 0;for(let d=i;d>=g;--d){const _=s.getTileRangeForExtentAndZ(t,d,this.tempTileRange_),M=s.getResolution(d);for(let S=_.minX;S<=_.maxX;++S)for(let E=_.minY;E<=_.maxY;++E){if(p&&!s.tileCoordIntersectsViewport([d,S,E],w))continue;const K=this.getTile(d,S,E,e);if(!K||!W(o,K,d))continue;const x=K.getKey();if(l[x]=!0,K.getState()===F.IDLE&&!e.tileQueue.isKeyQueued(x)){const Z=ce(d,S,E,this.tempTileCoord_);e.tileQueue.enqueue([K,n,s.getTileCoordCenter(Z),M])}}}}findStaleTile_(e,t){const i=this.tileCache_,o=e[0],a=e[1],u=e[2],r=this.getStaleKeys();for(let c=0;c<r.length;++c){const s=V(this.getLayer().getSource(),r[c],o,a,u);if(i.containsKey(s)){const n=i.peek(s);if(n.getState()===F.LOADED)return n.endTransition(I(this)),W(t,n,o),!0}}return!1}findAltTiles_(e,t,i,o){const a=e.getTileRangeForTileCoordAndZ(t,i,this.tempTileRange_);if(!a)return!1;let u=!0;const r=this.tileCache_,c=this.getLayer().getRenderSource(),s=c.getKey();for(let n=a.minX;n<=a.maxX;++n)for(let l=a.minY;l<=a.maxY;++l){const h=V(c,s,i,n,l);let g=!1;if(r.containsKey(h)){const p=r.peek(h);p.getState()===F.LOADED&&(W(o,p,i),g=!0)}g||(u=!1)}return u}renderFrame(e,t){this.renderComplete=!0;const i=e.layerStatesArray[e.layerIndex],o=e.viewState,a=o.projection,u=o.resolution,r=o.center,c=e.pixelRatio,s=this.getLayer(),n=s.getSource(),l=n.getTileGridForProjection(a),h=l.getZForResolution(u,n.zDirection),g=l.getResolution(h),p=n.getKey();this.renderedSourceKey_?this.renderedSourceKey_!==p&&(this.prependStaleKey(this.renderedSourceKey_),this.renderedSourceKey_=p):this.renderedSourceKey_=p;let w=e.extent;const d=n.getTilePixelRatio(c);this.prepareContainer(e,t);const _=this.context.canvas.width,M=this.context.canvas.height,S=i.extent&&H(i.extent);S&&(w=J(w,H(i.extent)));const E=g*_/2/d,K=g*M/2/d,z=[r[0]-E,r[1]-K,r[0]+E,r[1]+K],x={};this.renderedTiles.length=0;const Z=s.getPreload();if(e.nextExtent&&this.enqueueTilesForNextExtent()){const f=l.getZForResolution(o.nextResolution,n.zDirection),y=ue(e,e.nextExtent);this.enqueueTiles(e,y,f,x,Z)}const $=ue(e,w);if(this.enqueueTiles(e,$,h,x,0),Z>0&&setTimeout(()=>{this.enqueueTiles(e,$,h-1,x,Z-1)},0),!(h in x))return this.container;const ee=I(this),ge=e.time;for(const f of x[h]){const y=f.getState();if(y===F.EMPTY)continue;const j=f.tileCoord;if(y===F.LOADED&&f.getAlpha(ee,ge)===1){f.endTransition(ee);continue}if(y!==F.ERROR&&(this.renderComplete=!1),this.findStaleTile_(j,x)){ze(x,f,h),e.animate=!0;continue}if(this.findAltTiles_(l,j,h+1,x))continue;const D=l.getMinZoom();for(let v=h-1;v>=D&&!this.findAltTiles_(l,j,v,x);--v);}const k=g/u*c/d,T=this.getRenderContext(e);me(this.tempTransform,_/2,M/2,k,k,0,-_/2,-M/2),i.extent&&this.clipUnrotated(T,e,S),n.getInterpolate()||(T.imageSmoothingEnabled=!1),this.preRender(T,e);const G=Object.keys(x).map(Number);G.sort(je);let m;const B=[],te=[];for(let f=G.length-1;f>=0;--f){const y=G[f],j=n.getTilePixelSize(y,c,a),A=l.getResolution(y)/g,D=j[0]*A*k,v=j[1]*A*k,b=l.getTileCoordForCoordAndZ(Le(z),y),ie=l.getTileCoordExtent(b),q=ae(this.tempTransform,[d*(ie[0]-z[0])/g,d*(z[3]-ie[3])/g]),Te=d*n.getGutterForProjection(a);for(const O of x[y]){if(O.getState()!==F.LOADED)continue;const ne=O.tileCoord,oe=b[1]-ne[1],pe=Math.round(q[0]-(oe-1)*D),se=b[2]-ne[2],xe=Math.round(q[1]-(se-1)*v),L=Math.round(q[0]-oe*D),P=Math.round(q[1]-se*v),U=pe-L,X=xe-P,re=G.length===1;let Q=!1;m=[L,P,L+U,P,L+U,P+X,L,P+X];for(let Y=0,fe=B.length;Y<fe;++Y)if(!re&&y<te[Y]){const R=B[Y];Pe([L,P,L+U,P+X],[R[0],R[3],R[4],R[7]])&&(Q||(T.save(),Q=!0),T.beginPath(),T.moveTo(m[0],m[1]),T.lineTo(m[2],m[3]),T.lineTo(m[4],m[5]),T.lineTo(m[6],m[7]),T.moveTo(R[6],R[7]),T.lineTo(R[4],R[5]),T.lineTo(R[2],R[3]),T.lineTo(R[0],R[1]),T.clip())}B.push(m),te.push(y),this.drawTile(O,e,L,P,U,X,Te,re),Q&&T.restore(),this.renderedTiles.unshift(O),this.updateUsedTiles(e.usedTiles,n,O)}}if(this.renderedResolution=g,this.extentChanged=!this.renderedExtent_||!Fe(this.renderedExtent_,z),this.renderedExtent_=z,this.renderedPixelRatio=c,this.postRender(this.context,e),i.extent&&T.restore(),T.imageSmoothingEnabled=!0,this.renderComplete){const f=(y,j)=>{var v;const N=I(n),A=j.wantedTiles[N],D=A?Object.keys(A).length:0;this.updateCacheSize(D),this.tileCache_.expireCache(),(v=this.sourceTileCache_)==null||v.expireCache()};e.postRenderFunctions.push(f)}return this.container}updateCacheSize(e){this.tileCache_.highWaterMark=Math.max(this.tileCache_.highWaterMark,e*2)}drawTile(e,t,i,o,a,u,r,c){let s;if(e instanceof he){if(s=de(e.getData()),!s)throw new Error("Rendering array data is not yet supported")}else s=this.getTileImage(e);if(!s)return;const n=this.getRenderContext(t),l=I(this),h=t.layerStatesArray[t.layerIndex],g=h.opacity*(c?e.getAlpha(l,t.time):1),p=g!==n.globalAlpha;p&&(n.save(),n.globalAlpha=g),n.drawImage(s,r,r,s.width-2*r,s.height-2*r,i,o,a,u),p&&n.restore(),g!==h.opacity?t.animate=!0:c&&e.endTransition(l)}getImage(){const e=this.context;return e?e.canvas:null}getTileImage(e){return e.getImage()}updateUsedTiles(e,t,i){const o=I(t);o in e||(e[o]={}),e[o][i.getKey()]=!0}}class Oe extends ve{constructor(e){super(e)}createRenderer(){return new Ae(this,{cacheSize:this.getCacheSize()})}}export{Ae as C,Oe as T};
