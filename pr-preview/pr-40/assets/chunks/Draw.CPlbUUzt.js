import{L,M as A,b as U,G as K,a as Y,V as $,F as k,c as z}from"./Vector.CNch74hV.js";import{a5 as J,a6 as Q,U as Z,a7 as tt,a8 as et,a9 as it,aa as j,a2 as v,ab as V,ac as st,ad as nt,ae as ot,af as rt,ag as at,ah as G,ai as ht,aj as ct,ak as M,al as N,am as dt,an as lt,ao as C,ap as ft,aq as b,ar as I,as as O,q,p as ut,o as _t,n as gt,at as Ct,au as pt,av as yt}from"./XYZ.8i23LU2V.js";class S extends J{constructor(t,e,i){super(),i!==void 0&&e===void 0?this.setFlatCoordinates(i,t):(e=e||0,this.setCenterAndRadius(t,e,i))}clone(){const t=new S(this.flatCoordinates.slice(),void 0,this.layout);return t.applyProperties(this),t}closestPointXY(t,e,i,s){const n=this.flatCoordinates,o=t-n[0],r=e-n[1],a=o*o+r*r;if(a<s){if(a===0)for(let c=0;c<this.stride;++c)i[c]=n[c];else{const c=this.getRadius()/Math.sqrt(a);i[0]=n[0]+c*o,i[1]=n[1]+c*r;for(let d=2;d<this.stride;++d)i[d]=n[d]}return i.length=this.stride,a}return s}containsXY(t,e){const i=this.flatCoordinates,s=t-i[0],n=e-i[1];return s*s+n*n<=this.getRadiusSquared_()}getCenter(){return this.flatCoordinates.slice(0,this.stride)}computeExtent(t){const e=this.flatCoordinates,i=e[this.stride]-e[0];return Q(e[0]-i,e[1]-i,e[0]+i,e[1]+i,t)}getRadius(){return Math.sqrt(this.getRadiusSquared_())}getRadiusSquared_(){const t=this.flatCoordinates[this.stride]-this.flatCoordinates[0],e=this.flatCoordinates[this.stride+1]-this.flatCoordinates[1];return t*t+e*e}getType(){return"Circle"}intersectsExtent(t){const e=this.getExtent();if(Z(t,e)){const i=this.getCenter();return t[0]<=i[0]&&t[2]>=i[0]||t[1]<=i[1]&&t[3]>=i[1]?!0:tt(t,this.intersectsCoordinate.bind(this))}return!1}setCenter(t){const e=this.stride,i=this.flatCoordinates[e]-this.flatCoordinates[0],s=t.slice();s[e]=s[0]+i;for(let n=1;n<e;++n)s[e+n]=t[n];this.setFlatCoordinates(this.layout,s),this.changed()}setCenterAndRadius(t,e,i){this.setLayout(i,t,0),this.flatCoordinates||(this.flatCoordinates=[]);const s=this.flatCoordinates;let n=et(s,0,t,this.stride);s[n++]=s[0]+e;for(let o=1,r=this.stride;o<r;++o)s[n++]=s[o];s.length=n,this.changed()}getCoordinates(){return null}setCoordinates(t,e){}setRadius(t){this.flatCoordinates[this.stride]=this.flatCoordinates[0]+t,this.changed()}rotate(t,e){const i=this.getCenter(),s=this.getStride();this.setCenter(it(i,0,i.length,s,t,e,i)),this.changed()}}S.prototype.transform;function y(h,t){const e=h.length;return t<0?h[t+e]:t>=e?h[t-e]:h[t]}function m(h,t){const e=h.length;let i=Math.floor(t);const s=t-i;i>=e?i-=e:i<0&&(i+=e);let n=i+1;n>=e&&(n-=e);const o=h[i],r=o[0],a=o[1],c=h[n],d=c[0]-r,l=c[1]-a;return[r+d*s,a+l*s]}const T={index:-1,endIndex:NaN,closestTargetDistance:1/0};function mt(h,t,e,i){const s=h[0],n=h[1];let o=1/0,r=-1,a=NaN;for(let l=0;l<t.targets.length;++l){const f=t.targets[l],u=f.coordinates;let _=1/0,g;for(let p=0;p<u.length-1;++p){const H=u[p],X=u[p+1],E=B(s,n,H,X);E.squaredDistance<_&&(_=E.squaredDistance,g=p+E.along)}_<o&&(o=_,f.ring&&t.targetIndex===l&&(f.endIndex>f.startIndex?g<f.startIndex&&(g+=u.length):f.endIndex<f.startIndex&&g>f.startIndex&&(g-=u.length)),a=g,r=l)}const c=t.targets[r];let d=c.ring;if(t.targetIndex===r&&d){const l=m(c.coordinates,a),f=e.getPixelFromCoordinate(l),u=e.getPixelFromCoordinate(t.startCoord);j(f,u)>i&&(d=!1)}if(d){const l=c.coordinates,f=l.length,u=c.startIndex,_=a;if(u<_){const g=x(l,u,_);x(l,u,_-f)<g&&(a-=f)}else{const g=x(l,u,_);x(l,u,_+f)<g&&(a+=f)}}return T.index=r,T.endIndex=a,T.closestTargetDistance=o,T}function kt(h,t){const e=[];for(let i=0;i<t.length;++i){const n=t[i].getGeometry();W(h,n,e)}return e}function W(h,t,e){if(t instanceof L){w(h,t.getCoordinates(),!1,e);return}if(t instanceof A){const i=t.getCoordinates();for(let s=0,n=i.length;s<n;++s)w(h,i[s],!1,e);return}if(t instanceof v){const i=t.getCoordinates();for(let s=0,n=i.length;s<n;++s)w(h,i[s],!0,e);return}if(t instanceof U){const i=t.getCoordinates();for(let s=0,n=i.length;s<n;++s){const o=i[s];for(let r=0,a=o.length;r<a;++r)w(h,o[r],!0,e)}return}if(t instanceof K){const i=t.getGeometries();for(let s=0;s<i.length;++s)W(h,i[s],e);return}}function w(h,t,e,i){const s=h[0],n=h[1];for(let o=0,r=t.length-1;o<r;++o){const a=t[o],c=t[o+1],d=B(s,n,a,c);if(d.squaredDistance===0){const l=o+d.along;i.push({coordinates:t,ring:e,startIndex:l,endIndex:l});return}}}function P(h,t){return V(h[0],h[1],t[0],t[1])}function x(h,t,e){let i,s;t<e?(i=t,s=e):(i=e,s=t);const n=Math.ceil(i),o=Math.floor(s);if(n>o){const a=m(h,i),c=m(h,s);return P(a,c)}let r=0;if(i<n){const a=m(h,i),c=y(h,n);r+=P(a,c)}if(o<s){const a=y(h,o),c=m(h,s);r+=P(a,c)}for(let a=n;a<o-1;++a){const c=y(h,a),d=y(h,a+1);r+=P(c,d)}return r}const R={along:0,squaredDistance:0};function B(h,t,e,i){const s=e[0],n=e[1],o=i[0],r=i[1],a=o-s,c=r-n;let d=0,l=s,f=n;return(a!==0||c!==0)&&(d=nt(((h-s)*a+(t-n)*c)/(a*a+c*c),0,1),l+=a*d,f+=c*d),R.along=d,R.squaredDistance=st(V(h,t,l,f),10),R}const D={DRAWSTART:"drawstart",DRAWEND:"drawend",DRAWABORT:"drawabort"};class F extends yt{constructor(t,e){super(t),this.feature=e}}class Dt extends ot{constructor(t){const e=t;e.stopDown||(e.stopDown=rt),super(e),this.on,this.once,this.un,this.options_=t,this.shouldHandle_=!1,this.downPx_=null,this.downTimeout_,this.lastDragTime_,this.pointerType_,this.freehand_=!1,this.source_=t.source?t.source:null,this.features_=t.features?t.features:null,this.snapTolerance_=t.snapTolerance?t.snapTolerance:12,this.type_=t.type,this.mode_=wt(this.type_),this.stopClick_=!!t.stopClick,this.ignoreNextUpEvent_=!1,this.minPoints_=t.minPoints?t.minPoints:this.mode_==="Polygon"?3:2,this.maxPoints_=this.mode_==="Circle"?2:t.maxPoints?t.maxPoints:1/0,this.finishCondition_=t.finishCondition?t.finishCondition:at,this.geometryLayout_=t.geometryLayout?t.geometryLayout:"XY";let i=t.geometryFunction;if(!i){const s=this.mode_;if(s==="Circle")i=(n,o,r)=>{const a=o||new S([NaN,NaN]),c=G(n[0]),d=ht(c,G(n[n.length-1]));return a.setCenterAndRadius(c,Math.sqrt(d),this.geometryLayout_),a};else{let n;s==="Point"?n=I:s==="LineString"?n=L:s==="Polygon"&&(n=v),i=(o,r,a)=>(r?s==="Polygon"?o[0].length?r.setCoordinates([o[0].concat([o[0][0]])],this.geometryLayout_):r.setCoordinates([],this.geometryLayout_):r.setCoordinates(o,this.geometryLayout_):r=new n(o,this.geometryLayout_),r)}}this.geometryFunction_=i,this.dragVertexDelay_=t.dragVertexDelay!==void 0?t.dragVertexDelay:500,this.finishCoordinate_=null,this.sketchFeature_=null,this.sketchPoint_=null,this.sketchCoords_=null,this.sketchLine_=null,this.sketchLineCoords_=null,this.squaredClickTolerance_=t.clickTolerance?t.clickTolerance*t.clickTolerance:36,this.overlay_=new Y({source:new $({useSpatialIndex:!1,wrapX:t.wrapX?t.wrapX:!1}),style:t.style?t.style:Tt(),updateWhileInteracting:!0}),this.geometryName_=t.geometryName,this.condition_=t.condition?t.condition:ct,this.freehandCondition_,t.freehand?this.freehandCondition_=M:this.freehandCondition_=t.freehandCondition?t.freehandCondition:N,this.traceCondition_,this.setTrace(t.trace||!1),this.traceState_={active:!1},this.traceSource_=t.traceSource||t.source||null,this.addChangeListener(dt.ACTIVE,this.updateState_)}setTrace(t){let e;t?t===!0?e=M:e=t:e=Ct,this.traceCondition_=e}setMap(t){super.setMap(t),this.updateState_()}setFreehand(t){this.freehand_=t,this.freehand_?this.freehandCondition_=M:this.freehandCondition_=this.options_&&this.options_.freehandCondition?this.options_.freehandCondition:N}getOverlay(){return this.overlay_}getFreehand(){return this.freehand_}handleEvent(t){t.originalEvent.type===lt.CONTEXTMENU&&t.originalEvent.preventDefault(),this.freehand_=this.mode_!=="Point"&&this.freehandCondition_(t);let e=t.type===C.POINTERMOVE,i=!0;return!this.freehand_&&this.lastDragTime_&&t.type===C.POINTERDRAG&&(Date.now()-this.lastDragTime_>=this.dragVertexDelay_?(this.downPx_=t.pixel,this.shouldHandle_=!this.freehand_,e=!0):this.lastDragTime_=void 0,this.shouldHandle_&&this.downTimeout_!==void 0&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0)),this.freehand_&&t.type===C.POINTERDRAG&&this.sketchFeature_!==null?(this.addToDrawing_(t.coordinate),i=!1):this.freehand_&&t.type===C.POINTERDOWN?i=!1:e&&this.getPointerCount()<2?(i=t.type===C.POINTERMOVE,i&&this.freehand_?(this.handlePointerMove_(t),this.shouldHandle_&&t.originalEvent.preventDefault()):(t.originalEvent.pointerType==="mouse"||t.type===C.POINTERDRAG&&this.downTimeout_===void 0)&&this.handlePointerMove_(t)):t.type===C.DBLCLICK&&(i=!1),super.handleEvent(t)&&i}handleDownEvent(t){return this.shouldHandle_=!this.freehand_,this.freehand_?(this.downPx_=t.pixel,this.finishCoordinate_||this.startDrawing_(t.coordinate),!0):this.condition_(t)?(this.lastDragTime_=Date.now(),this.downTimeout_=setTimeout(()=>{this.handlePointerMove_(new ft(C.POINTERMOVE,t.map,t.originalEvent,!1,t.frameState))},this.dragVertexDelay_),this.downPx_=t.pixel,!0):(this.lastDragTime_=void 0,!1)}deactivateTrace_(){this.traceState_={active:!1}}toggleTraceState_(t){if(!this.traceSource_||!this.traceCondition_(t))return;if(this.traceState_.active){this.deactivateTrace_();return}const e=this.getMap(),i=e.getCoordinateFromPixel([t.pixel[0]-this.snapTolerance_,t.pixel[1]+this.snapTolerance_]),s=e.getCoordinateFromPixel([t.pixel[0]+this.snapTolerance_,t.pixel[1]-this.snapTolerance_]),n=b([i,s]),o=this.traceSource_.getFeaturesInExtent(n);if(o.length===0)return;const r=kt(t.coordinate,o);r.length&&(this.traceState_={active:!0,startCoord:t.coordinate.slice(),targets:r,targetIndex:-1})}addOrRemoveTracedCoordinates_(t,e){const i=t.startIndex<=t.endIndex,s=t.startIndex<=e;i===s?i&&e>t.endIndex||!i&&e<t.endIndex?this.addTracedCoordinates_(t,t.endIndex,e):(i&&e<t.endIndex||!i&&e>t.endIndex)&&this.removeTracedCoordinates_(e,t.endIndex):(this.removeTracedCoordinates_(t.startIndex,t.endIndex),this.addTracedCoordinates_(t,t.startIndex,e))}removeTracedCoordinates_(t,e){if(t===e)return;let i=0;if(t<e){const s=Math.ceil(t);let n=Math.floor(e);n===e&&(n-=1),i=n-s+1}else{const s=Math.floor(t);let n=Math.ceil(e);n===e&&(n+=1),i=s-n+1}i>0&&this.removeLastPoints_(i)}addTracedCoordinates_(t,e,i){if(e===i)return;const s=[];if(e<i){const n=Math.ceil(e);let o=Math.floor(i);o===i&&(o-=1);for(let r=n;r<=o;++r)s.push(y(t.coordinates,r))}else{const n=Math.floor(e);let o=Math.ceil(i);o===i&&(o+=1);for(let r=n;r>=o;--r)s.push(y(t.coordinates,r))}s.length&&this.appendCoordinates(s)}updateTrace_(t){const e=this.traceState_;if(!e.active)return;if(e.targetIndex===-1){const r=t.map.getPixelFromCoordinate(e.startCoord);if(j(r,t.pixel)<this.snapTolerance_)return}const i=mt(t.coordinate,e,this.getMap(),this.snapTolerance_);if(e.targetIndex!==i.index){if(e.targetIndex!==-1){const a=e.targets[e.targetIndex];this.removeTracedCoordinates_(a.startIndex,a.endIndex)}const r=e.targets[i.index];this.addTracedCoordinates_(r,r.startIndex,i.endIndex)}else{const r=e.targets[e.targetIndex];this.addOrRemoveTracedCoordinates_(r,i.endIndex)}e.targetIndex=i.index;const s=e.targets[e.targetIndex];s.endIndex=i.endIndex;const n=m(s.coordinates,s.endIndex),o=this.getMap().getPixelFromCoordinate(n);t.coordinate=n,t.pixel=[Math.round(o[0]),Math.round(o[1])]}handleDragEvent(t){this.ignoreNextUpEvent_=!0,super.handleDragEvent(t)}handleUpEvent(t){let e=!0;if(this.getPointerCount()===0){this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0),this.handlePointerMove_(t);const i=this.traceState_.active;if(this.ignoreNextUpEvent_||this.toggleTraceState_(t),this.shouldHandle_){const s=!this.finishCoordinate_;s&&this.startDrawing_(t.coordinate),!s&&this.freehand_?this.finishDrawing():!this.freehand_&&(!s||this.mode_==="Point")&&(this.atFinish_(t.pixel,i)?this.finishCondition_(t)&&this.finishDrawing():this.addToDrawing_(t.coordinate)),e=!1}else this.freehand_&&this.abortDrawing()}return this.ignoreNextUpEvent_=!1,!e&&this.stopClick_&&t.preventDefault(),e}handlePointerMove_(t){if(this.pointerType_=t.originalEvent.pointerType,this.downPx_&&(!this.freehand_&&this.shouldHandle_||this.freehand_&&!this.shouldHandle_)){const e=this.downPx_,i=t.pixel,s=e[0]-i[0],n=e[1]-i[1],o=s*s+n*n;if(this.shouldHandle_=this.freehand_?o>this.squaredClickTolerance_:o<=this.squaredClickTolerance_,!this.shouldHandle_)return}if(!this.finishCoordinate_){this.createOrUpdateSketchPoint_(t.coordinate.slice());return}this.updateTrace_(t),this.modifyDrawing_(t.coordinate)}atFinish_(t,e){let i=!1;if(this.sketchFeature_){let s=!1,n=[this.finishCoordinate_];const o=this.mode_;if(o==="Point")i=!0;else if(o==="Circle")i=this.sketchCoords_.length===2;else if(o==="LineString")s=!e&&this.sketchCoords_.length>this.minPoints_;else if(o==="Polygon"){const r=this.sketchCoords_;s=r[0].length>this.minPoints_,n=[r[0][0],r[0][r[0].length-2]],e?n=[r[0][0]]:n=[r[0][0],r[0][r[0].length-2]]}if(s){const r=this.getMap();for(let a=0,c=n.length;a<c;a++){const d=n[a],l=r.getPixelFromCoordinate(d),f=t[0]-l[0],u=t[1]-l[1],_=this.freehand_?1:this.snapTolerance_;if(i=Math.sqrt(f*f+u*u)<=_,i){this.finishCoordinate_=d;break}}}}return i}createOrUpdateSketchPoint_(t){this.sketchPoint_?this.sketchPoint_.getGeometry().setCoordinates(t):(this.sketchPoint_=new k(new I(t)),this.updateSketchFeatures_())}createOrUpdateCustomSketchLine_(t){this.sketchLine_||(this.sketchLine_=new k);const e=t.getLinearRing(0);let i=this.sketchLine_.getGeometry();i?(i.setFlatCoordinates(e.getLayout(),e.getFlatCoordinates()),i.changed()):(i=new L(e.getFlatCoordinates(),e.getLayout()),this.sketchLine_.setGeometry(i))}startDrawing_(t){const e=this.getMap().getView().getProjection(),i=O(this.geometryLayout_);for(;t.length<i;)t.push(0);this.finishCoordinate_=t,this.mode_==="Point"?this.sketchCoords_=t.slice():this.mode_==="Polygon"?(this.sketchCoords_=[[t.slice(),t.slice()]],this.sketchLineCoords_=this.sketchCoords_[0]):this.sketchCoords_=[t.slice(),t.slice()],this.sketchLineCoords_&&(this.sketchLine_=new k(new L(this.sketchLineCoords_)));const s=this.geometryFunction_(this.sketchCoords_,void 0,e);this.sketchFeature_=new k,this.geometryName_&&this.sketchFeature_.setGeometryName(this.geometryName_),this.sketchFeature_.setGeometry(s),this.updateSketchFeatures_(),this.dispatchEvent(new F(D.DRAWSTART,this.sketchFeature_))}modifyDrawing_(t){const e=this.getMap(),i=this.sketchFeature_.getGeometry(),s=e.getView().getProjection(),n=O(this.geometryLayout_);let o,r;for(;t.length<n;)t.push(0);this.mode_==="Point"?r=this.sketchCoords_:this.mode_==="Polygon"?(o=this.sketchCoords_[0],r=o[o.length-1],this.atFinish_(e.getPixelFromCoordinate(t))&&(t=this.finishCoordinate_.slice())):(o=this.sketchCoords_,r=o[o.length-1]),r[0]=t[0],r[1]=t[1],this.geometryFunction_(this.sketchCoords_,i,s),this.sketchPoint_&&this.sketchPoint_.getGeometry().setCoordinates(t),i.getType()==="Polygon"&&this.mode_!=="Polygon"?this.createOrUpdateCustomSketchLine_(i):this.sketchLineCoords_&&this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_),this.updateSketchFeatures_()}addToDrawing_(t){const e=this.sketchFeature_.getGeometry(),i=this.getMap().getView().getProjection();let s,n;const o=this.mode_;return o==="LineString"||o==="Circle"?(this.finishCoordinate_=t.slice(),n=this.sketchCoords_,n.length>=this.maxPoints_&&(this.freehand_?n.pop():s=!0),n.push(t.slice()),this.geometryFunction_(n,e,i)):o==="Polygon"&&(n=this.sketchCoords_[0],n.length>=this.maxPoints_&&(this.freehand_?n.pop():s=!0),n.push(t.slice()),s&&(this.finishCoordinate_=n[0]),this.geometryFunction_(this.sketchCoords_,e,i)),this.createOrUpdateSketchPoint_(t.slice()),this.updateSketchFeatures_(),s?this.finishDrawing():this.sketchFeature_}removeLastPoints_(t){if(!this.sketchFeature_)return;const e=this.sketchFeature_.getGeometry(),i=this.getMap().getView().getProjection(),s=this.mode_;for(let n=0;n<t;++n){let o;if(s==="LineString"||s==="Circle"){if(o=this.sketchCoords_,o.splice(-2,1),o.length>=2){this.finishCoordinate_=o[o.length-2].slice();const r=this.finishCoordinate_.slice();o[o.length-1]=r,this.createOrUpdateSketchPoint_(r)}this.geometryFunction_(o,e,i),e.getType()==="Polygon"&&this.sketchLine_&&this.createOrUpdateCustomSketchLine_(e)}else if(s==="Polygon"){o=this.sketchCoords_[0],o.splice(-2,1);const r=this.sketchLine_.getGeometry();if(o.length>=2){const a=o[o.length-2].slice();o[o.length-1]=a,this.createOrUpdateSketchPoint_(a)}r.setCoordinates(o),this.geometryFunction_(this.sketchCoords_,e,i)}if(o.length===1){this.abortDrawing();break}}this.updateSketchFeatures_()}removeLastPoint(){this.removeLastPoints_(1)}finishDrawing(){const t=this.abortDrawing_();if(!t)return null;let e=this.sketchCoords_;const i=t.getGeometry(),s=this.getMap().getView().getProjection();return this.mode_==="LineString"?(e.pop(),this.geometryFunction_(e,i,s)):this.mode_==="Polygon"&&(e[0].pop(),this.geometryFunction_(e,i,s),e=i.getCoordinates()),this.type_==="MultiPoint"?t.setGeometry(new z([e])):this.type_==="MultiLineString"?t.setGeometry(new A([e])):this.type_==="MultiPolygon"&&t.setGeometry(new U([e])),this.dispatchEvent(new F(D.DRAWEND,t)),this.features_&&this.features_.push(t),this.source_&&this.source_.addFeature(t),t}abortDrawing_(){this.finishCoordinate_=null;const t=this.sketchFeature_;return this.sketchFeature_=null,this.sketchPoint_=null,this.sketchLine_=null,this.overlay_.getSource().clear(!0),this.deactivateTrace_(),t}abortDrawing(){const t=this.abortDrawing_();t&&this.dispatchEvent(new F(D.DRAWABORT,t))}appendCoordinates(t){const e=this.mode_,i=!this.sketchFeature_;i&&this.startDrawing_(t[0]);let s;if(e==="LineString"||e==="Circle")s=this.sketchCoords_;else if(e==="Polygon")s=this.sketchCoords_&&this.sketchCoords_.length?this.sketchCoords_[0]:[];else return;i&&s.shift(),s.pop();for(let o=0;o<t.length;o++)this.addToDrawing_(t[o]);const n=t[t.length-1];this.sketchFeature_=this.addToDrawing_(n),this.modifyDrawing_(n)}extend(t){const i=t.getGeometry();this.sketchFeature_=t,this.sketchCoords_=i.getCoordinates();const s=this.sketchCoords_[this.sketchCoords_.length-1];this.finishCoordinate_=s.slice(),this.sketchCoords_.push(s.slice()),this.sketchPoint_=new k(new I(s)),this.updateSketchFeatures_(),this.dispatchEvent(new F(D.DRAWSTART,this.sketchFeature_))}updateSketchFeatures_(){const t=[];this.sketchFeature_&&t.push(this.sketchFeature_),this.sketchLine_&&t.push(this.sketchLine_),this.sketchPoint_&&t.push(this.sketchPoint_);const e=this.overlay_.getSource();e.clear(!0),e.addFeatures(t)}updateState_(){const t=this.getMap(),e=this.getActive();(!t||!e)&&this.abortDrawing(),this.overlay_.setMap(e?t:null)}}function Tt(){const h=pt();return function(t,e){return h[t.getGeometry().getType()]}}function Ft(){return function(h,t,e){const i=b([h[0],h[h.length-1]].map(function(n){return G(n)})),s=[[q(i),ut(i),_t(i),gt(i),q(i)]];return t?t.setCoordinates(s):t=new v(s),t}}function wt(h){switch(h){case"Point":case"MultiPoint":return"Point";case"LineString":case"MultiLineString":return"LineString";case"Polygon":case"MultiPolygon":return"Polygon";case"Circle":return"Circle";default:throw new Error("Invalid type: "+h)}}export{Dt as D,Ft as c};
