import{q as A,L,M as U,P as R,r as q,G as X,s as V,u as K,v as z,x as J,y as Q,C as Y,z as G,A as $,d as Z,V as tt,E as et,B as j,h as k,H as M,I as v,J as it,K as N,N as st,Q as nt,R as ot,U as rt,X as at}from"./olcs.2jv08wJ5.js";import{P as ht,n as ct,a as E,s as O,I as lt,b as p,c as dt,d as _t}from"./Map.Cy1OztE9.js";function m(a,t){const e=a.length;return t<0?a[t+e]:t>=e?a[t-e]:a[t]}function y(a,t){const e=a.length;let i=Math.floor(t);const s=t-i;i>=e?i-=e:i<0&&(i+=e);let o=i+1;o>=e&&(o-=e);const n=a[i],r=n[0],h=n[1],c=a[o],_=c[0]-r,l=c[1]-h;return[r+_*s,h+l*s]}const T={index:-1,endIndex:NaN,closestTargetDistance:1/0};function ft(a,t,e,i){const s=a[0],o=a[1];let n=1/0,r=-1,h=NaN;for(let l=0;l<t.targets.length;++l){const d=t.targets[l],f=d.coordinates;let u=1/0,g;for(let C=0;C<f.length-1;++C){const H=f[C],W=f[C+1],S=B(s,o,H,W);S.squaredDistance<u&&(u=S.squaredDistance,g=C+S.along)}u<n&&(n=u,d.ring&&t.targetIndex===l&&(d.endIndex>d.startIndex?g<d.startIndex&&(g+=f.length):d.endIndex<d.startIndex&&g>d.startIndex&&(g-=f.length)),h=g,r=l)}const c=t.targets[r];let _=c.ring;if(t.targetIndex===r&&_){const l=y(c.coordinates,h),d=e.getPixelFromCoordinate(l),f=e.getPixelFromCoordinate(t.startCoord);A(d,f)>i&&(_=!1)}if(_){const l=c.coordinates,d=l.length,f=c.startIndex,u=h;if(f<u){const g=x(l,f,u);x(l,f,u-d)<g&&(h-=d)}else{const g=x(l,f,u);x(l,f,u+d)<g&&(h+=d)}}return T.index=r,T.endIndex=h,T.closestTargetDistance=n,T}function ut(a,t){const e=[];for(let i=0;i<t.length;++i){const o=t[i].getGeometry();b(a,o,e)}return e}function b(a,t,e){if(t instanceof L){P(a,t.getCoordinates(),!1,e);return}if(t instanceof U){const i=t.getCoordinates();for(let s=0,o=i.length;s<o;++s)P(a,i[s],!1,e);return}if(t instanceof R){const i=t.getCoordinates();for(let s=0,o=i.length;s<o;++s)P(a,i[s],!0,e);return}if(t instanceof q){const i=t.getCoordinates();for(let s=0,o=i.length;s<o;++s){const n=i[s];for(let r=0,h=n.length;r<h;++r)P(a,n[r],!0,e)}return}if(t instanceof X){const i=t.getGeometries();for(let s=0;s<i.length;++s)b(a,i[s],e);return}}function P(a,t,e,i){const s=a[0],o=a[1];for(let n=0,r=t.length-1;n<r;++n){const h=t[n],c=t[n+1],_=B(s,o,h,c);if(_.squaredDistance===0){const l=n+_.along;i.push({coordinates:t,ring:e,startIndex:l,endIndex:l});return}}}function w(a,t){return V(a[0],a[1],t[0],t[1])}function x(a,t,e){let i,s;t<e?(i=t,s=e):(i=e,s=t);const o=Math.ceil(i),n=Math.floor(s);if(o>n){const h=y(a,i),c=y(a,s);return w(h,c)}let r=0;if(i<o){const h=y(a,i),c=m(a,o);r+=w(h,c)}if(n<s){const h=m(a,n),c=y(a,s);r+=w(h,c)}for(let h=o;h<n-1;++h){const c=m(a,h),_=m(a,h+1);r+=w(c,_)}return r}const I={along:0,squaredDistance:0};function B(a,t,e,i){const s=e[0],o=e[1],n=i[0],r=i[1],h=n-s,c=r-o;let _=0,l=s,d=o;return(h!==0||c!==0)&&(_=z(((a-s)*h+(t-o)*c)/(h*h+c*c),0,1),l+=h*_,d+=c*_),I.along=_,I.squaredDistance=K(V(a,t,l,d),10),I}const D={DRAWSTART:"drawstart",DRAWEND:"drawend",DRAWABORT:"drawabort"};class F extends at{constructor(t,e){super(t),this.feature=e}}class yt extends ht{constructor(t){const e=t;e.stopDown||(e.stopDown=J),super(e),this.on,this.once,this.un,this.options_=t,this.shouldHandle_=!1,this.downPx_=null,this.downTimeout_,this.lastDragTime_,this.pointerType_,this.freehand_=!1,this.source_=t.source?t.source:null,this.features_=t.features?t.features:null,this.snapTolerance_=t.snapTolerance?t.snapTolerance:12,this.type_=t.type,this.mode_=pt(this.type_),this.stopClick_=!!t.stopClick,this.ignoreNextUpEvent_=!1,this.minPoints_=t.minPoints?t.minPoints:this.mode_==="Polygon"?3:2,this.maxPoints_=this.mode_==="Circle"?2:t.maxPoints?t.maxPoints:1/0,this.finishCondition_=t.finishCondition?t.finishCondition:Q,this.geometryLayout_=t.geometryLayout?t.geometryLayout:"XY";let i=t.geometryFunction;if(!i){const s=this.mode_;if(s==="Circle")i=(o,n,r)=>{const h=n||new Y([NaN,NaN]),c=G(o[0]),_=$(c,G(o[o.length-1]));return h.setCenterAndRadius(c,Math.sqrt(_),this.geometryLayout_),h};else{let o;s==="Point"?o=M:s==="LineString"?o=L:s==="Polygon"&&(o=R),i=(n,r,h)=>(r?s==="Polygon"?n[0].length?r.setCoordinates([n[0].concat([n[0][0]])],this.geometryLayout_):r.setCoordinates([],this.geometryLayout_):r.setCoordinates(n,this.geometryLayout_):r=new o(n,this.geometryLayout_),r)}}this.geometryFunction_=i,this.dragVertexDelay_=t.dragVertexDelay!==void 0?t.dragVertexDelay:500,this.finishCoordinate_=null,this.sketchFeature_=null,this.sketchPoint_=null,this.sketchCoords_=null,this.sketchLine_=null,this.sketchLineCoords_=null,this.squaredClickTolerance_=t.clickTolerance?t.clickTolerance*t.clickTolerance:36,this.overlay_=new Z({source:new tt({useSpatialIndex:!1,wrapX:t.wrapX?t.wrapX:!1}),style:t.style?t.style:gt(),updateWhileInteracting:!0}),this.geometryName_=t.geometryName,this.condition_=t.condition?t.condition:ct,this.freehandCondition_,t.freehand?this.freehandCondition_=E:this.freehandCondition_=t.freehandCondition?t.freehandCondition:O,this.traceCondition_,this.setTrace(t.trace||!1),this.traceState_={active:!1},this.traceSource_=t.traceSource||t.source||null,this.addChangeListener(lt.ACTIVE,this.updateState_)}setTrace(t){let e;t?t===!0?e=E:e=t:e=_t,this.traceCondition_=e}setMap(t){super.setMap(t),this.updateState_()}setFreehand(t){this.freehand_=t,this.freehand_?this.freehandCondition_=E:this.freehandCondition_=this.options_&&this.options_.freehandCondition?this.options_.freehandCondition:O}getOverlay(){return this.overlay_}getFreehand(){return this.freehand_}handleEvent(t){t.originalEvent.type===et.CONTEXTMENU&&t.originalEvent.preventDefault(),this.freehand_=this.mode_!=="Point"&&this.freehandCondition_(t);let e=t.type===p.POINTERMOVE,i=!0;return!this.freehand_&&this.lastDragTime_&&t.type===p.POINTERDRAG&&(Date.now()-this.lastDragTime_>=this.dragVertexDelay_?(this.downPx_=t.pixel,this.shouldHandle_=!this.freehand_,e=!0):this.lastDragTime_=void 0,this.shouldHandle_&&this.downTimeout_!==void 0&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0)),this.freehand_&&t.type===p.POINTERDRAG&&this.sketchFeature_!==null?(this.addToDrawing_(t.coordinate),i=!1):this.freehand_&&t.type===p.POINTERDOWN?i=!1:e&&this.getPointerCount()<2?(i=t.type===p.POINTERMOVE,i&&this.freehand_?(this.handlePointerMove_(t),this.shouldHandle_&&t.originalEvent.preventDefault()):(t.originalEvent.pointerType==="mouse"||t.type===p.POINTERDRAG&&this.downTimeout_===void 0)&&this.handlePointerMove_(t)):t.type===p.DBLCLICK&&(i=!1),super.handleEvent(t)&&i}handleDownEvent(t){return this.shouldHandle_=!this.freehand_,this.freehand_?(this.downPx_=t.pixel,this.finishCoordinate_||this.startDrawing_(t.coordinate),!0):this.condition_(t)?(this.lastDragTime_=Date.now(),this.downTimeout_=setTimeout(()=>{this.handlePointerMove_(new dt(p.POINTERMOVE,t.map,t.originalEvent,!1,t.frameState))},this.dragVertexDelay_),this.downPx_=t.pixel,!0):(this.lastDragTime_=void 0,!1)}deactivateTrace_(){this.traceState_={active:!1}}toggleTraceState_(t){if(!this.traceSource_||!this.traceCondition_(t))return;if(this.traceState_.active){this.deactivateTrace_();return}const e=this.getMap(),i=e.getCoordinateFromPixel([t.pixel[0]-this.snapTolerance_,t.pixel[1]+this.snapTolerance_]),s=e.getCoordinateFromPixel([t.pixel[0]+this.snapTolerance_,t.pixel[1]-this.snapTolerance_]),o=j([i,s]),n=this.traceSource_.getFeaturesInExtent(o);if(n.length===0)return;const r=ut(t.coordinate,n);r.length&&(this.traceState_={active:!0,startCoord:t.coordinate.slice(),targets:r,targetIndex:-1})}addOrRemoveTracedCoordinates_(t,e){const i=t.startIndex<=t.endIndex,s=t.startIndex<=e;i===s?i&&e>t.endIndex||!i&&e<t.endIndex?this.addTracedCoordinates_(t,t.endIndex,e):(i&&e<t.endIndex||!i&&e>t.endIndex)&&this.removeTracedCoordinates_(e,t.endIndex):(this.removeTracedCoordinates_(t.startIndex,t.endIndex),this.addTracedCoordinates_(t,t.startIndex,e))}removeTracedCoordinates_(t,e){if(t===e)return;let i=0;if(t<e){const s=Math.ceil(t);let o=Math.floor(e);o===e&&(o-=1),i=o-s+1}else{const s=Math.floor(t);let o=Math.ceil(e);o===e&&(o+=1),i=s-o+1}i>0&&this.removeLastPoints_(i)}addTracedCoordinates_(t,e,i){if(e===i)return;const s=[];if(e<i){const o=Math.ceil(e);let n=Math.floor(i);n===i&&(n-=1);for(let r=o;r<=n;++r)s.push(m(t.coordinates,r))}else{const o=Math.floor(e);let n=Math.ceil(i);n===i&&(n+=1);for(let r=o;r>=n;--r)s.push(m(t.coordinates,r))}s.length&&this.appendCoordinates(s)}updateTrace_(t){const e=this.traceState_;if(!e.active)return;if(e.targetIndex===-1){const r=t.map.getPixelFromCoordinate(e.startCoord);if(A(r,t.pixel)<this.snapTolerance_)return}const i=ft(t.coordinate,e,this.getMap(),this.snapTolerance_);if(e.targetIndex!==i.index){if(e.targetIndex!==-1){const h=e.targets[e.targetIndex];this.removeTracedCoordinates_(h.startIndex,h.endIndex)}const r=e.targets[i.index];this.addTracedCoordinates_(r,r.startIndex,i.endIndex)}else{const r=e.targets[e.targetIndex];this.addOrRemoveTracedCoordinates_(r,i.endIndex)}e.targetIndex=i.index;const s=e.targets[e.targetIndex];s.endIndex=i.endIndex;const o=y(s.coordinates,s.endIndex),n=this.getMap().getPixelFromCoordinate(o);t.coordinate=o,t.pixel=[Math.round(n[0]),Math.round(n[1])]}handleDragEvent(t){this.ignoreNextUpEvent_=!0,super.handleDragEvent(t)}handleUpEvent(t){let e=!0;if(this.getPointerCount()===0){this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0),this.handlePointerMove_(t);const i=this.traceState_.active;if(this.ignoreNextUpEvent_||this.toggleTraceState_(t),this.shouldHandle_){const s=!this.finishCoordinate_;s&&this.startDrawing_(t.coordinate),!s&&this.freehand_?this.finishDrawing():!this.freehand_&&(!s||this.mode_==="Point")&&(this.atFinish_(t.pixel,i)?this.finishCondition_(t)&&this.finishDrawing():this.addToDrawing_(t.coordinate)),e=!1}else this.freehand_&&this.abortDrawing()}return this.ignoreNextUpEvent_=!1,!e&&this.stopClick_&&t.preventDefault(),e}handlePointerMove_(t){if(this.pointerType_=t.originalEvent.pointerType,this.downPx_&&(!this.freehand_&&this.shouldHandle_||this.freehand_&&!this.shouldHandle_)){const e=this.downPx_,i=t.pixel,s=e[0]-i[0],o=e[1]-i[1],n=s*s+o*o;if(this.shouldHandle_=this.freehand_?n>this.squaredClickTolerance_:n<=this.squaredClickTolerance_,!this.shouldHandle_)return}if(!this.finishCoordinate_){this.createOrUpdateSketchPoint_(t.coordinate.slice());return}this.updateTrace_(t),this.modifyDrawing_(t.coordinate)}atFinish_(t,e){let i=!1;if(this.sketchFeature_){let s=!1,o=[this.finishCoordinate_];const n=this.mode_;if(n==="Point")i=!0;else if(n==="Circle")i=this.sketchCoords_.length===2;else if(n==="LineString")s=!e&&this.sketchCoords_.length>this.minPoints_;else if(n==="Polygon"){const r=this.sketchCoords_;s=r[0].length>this.minPoints_,o=[r[0][0],r[0][r[0].length-2]],e?o=[r[0][0]]:o=[r[0][0],r[0][r[0].length-2]]}if(s){const r=this.getMap();for(let h=0,c=o.length;h<c;h++){const _=o[h],l=r.getPixelFromCoordinate(_),d=t[0]-l[0],f=t[1]-l[1],u=this.freehand_?1:this.snapTolerance_;if(i=Math.sqrt(d*d+f*f)<=u,i){this.finishCoordinate_=_;break}}}}return i}createOrUpdateSketchPoint_(t){this.sketchPoint_?this.sketchPoint_.getGeometry().setCoordinates(t):(this.sketchPoint_=new k(new M(t)),this.updateSketchFeatures_())}createOrUpdateCustomSketchLine_(t){this.sketchLine_||(this.sketchLine_=new k);const e=t.getLinearRing(0);let i=this.sketchLine_.getGeometry();i?(i.setFlatCoordinates(e.getLayout(),e.getFlatCoordinates()),i.changed()):(i=new L(e.getFlatCoordinates(),e.getLayout()),this.sketchLine_.setGeometry(i))}startDrawing_(t){const e=this.getMap().getView().getProjection(),i=v(this.geometryLayout_);for(;t.length<i;)t.push(0);this.finishCoordinate_=t,this.mode_==="Point"?this.sketchCoords_=t.slice():this.mode_==="Polygon"?(this.sketchCoords_=[[t.slice(),t.slice()]],this.sketchLineCoords_=this.sketchCoords_[0]):this.sketchCoords_=[t.slice(),t.slice()],this.sketchLineCoords_&&(this.sketchLine_=new k(new L(this.sketchLineCoords_)));const s=this.geometryFunction_(this.sketchCoords_,void 0,e);this.sketchFeature_=new k,this.geometryName_&&this.sketchFeature_.setGeometryName(this.geometryName_),this.sketchFeature_.setGeometry(s),this.updateSketchFeatures_(),this.dispatchEvent(new F(D.DRAWSTART,this.sketchFeature_))}modifyDrawing_(t){const e=this.getMap(),i=this.sketchFeature_.getGeometry(),s=e.getView().getProjection(),o=v(this.geometryLayout_);let n,r;for(;t.length<o;)t.push(0);this.mode_==="Point"?r=this.sketchCoords_:this.mode_==="Polygon"?(n=this.sketchCoords_[0],r=n[n.length-1],this.atFinish_(e.getPixelFromCoordinate(t))&&(t=this.finishCoordinate_.slice())):(n=this.sketchCoords_,r=n[n.length-1]),r[0]=t[0],r[1]=t[1],this.geometryFunction_(this.sketchCoords_,i,s),this.sketchPoint_&&this.sketchPoint_.getGeometry().setCoordinates(t),i.getType()==="Polygon"&&this.mode_!=="Polygon"?this.createOrUpdateCustomSketchLine_(i):this.sketchLineCoords_&&this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_),this.updateSketchFeatures_()}addToDrawing_(t){const e=this.sketchFeature_.getGeometry(),i=this.getMap().getView().getProjection();let s,o;const n=this.mode_;return n==="LineString"||n==="Circle"?(this.finishCoordinate_=t.slice(),o=this.sketchCoords_,o.length>=this.maxPoints_&&(this.freehand_?o.pop():s=!0),o.push(t.slice()),this.geometryFunction_(o,e,i)):n==="Polygon"&&(o=this.sketchCoords_[0],o.length>=this.maxPoints_&&(this.freehand_?o.pop():s=!0),o.push(t.slice()),s&&(this.finishCoordinate_=o[0]),this.geometryFunction_(this.sketchCoords_,e,i)),this.createOrUpdateSketchPoint_(t.slice()),this.updateSketchFeatures_(),s?this.finishDrawing():this.sketchFeature_}removeLastPoints_(t){if(!this.sketchFeature_)return;const e=this.sketchFeature_.getGeometry(),i=this.getMap().getView().getProjection(),s=this.mode_;for(let o=0;o<t;++o){let n;if(s==="LineString"||s==="Circle"){if(n=this.sketchCoords_,n.splice(-2,1),n.length>=2){this.finishCoordinate_=n[n.length-2].slice();const r=this.finishCoordinate_.slice();n[n.length-1]=r,this.createOrUpdateSketchPoint_(r)}this.geometryFunction_(n,e,i),e.getType()==="Polygon"&&this.sketchLine_&&this.createOrUpdateCustomSketchLine_(e)}else if(s==="Polygon"){n=this.sketchCoords_[0],n.splice(-2,1);const r=this.sketchLine_.getGeometry();if(n.length>=2){const h=n[n.length-2].slice();n[n.length-1]=h,this.createOrUpdateSketchPoint_(h)}r.setCoordinates(n),this.geometryFunction_(this.sketchCoords_,e,i)}if(n.length===1){this.abortDrawing();break}}this.updateSketchFeatures_()}removeLastPoint(){this.removeLastPoints_(1)}finishDrawing(){const t=this.abortDrawing_();if(!t)return null;let e=this.sketchCoords_;const i=t.getGeometry(),s=this.getMap().getView().getProjection();return this.mode_==="LineString"?(e.pop(),this.geometryFunction_(e,i,s)):this.mode_==="Polygon"&&(e[0].pop(),this.geometryFunction_(e,i,s),e=i.getCoordinates()),this.type_==="MultiPoint"?t.setGeometry(new it([e])):this.type_==="MultiLineString"?t.setGeometry(new U([e])):this.type_==="MultiPolygon"&&t.setGeometry(new q([e])),this.dispatchEvent(new F(D.DRAWEND,t)),this.features_&&this.features_.push(t),this.source_&&this.source_.addFeature(t),t}abortDrawing_(){this.finishCoordinate_=null;const t=this.sketchFeature_;return this.sketchFeature_=null,this.sketchPoint_=null,this.sketchLine_=null,this.overlay_.getSource().clear(!0),this.deactivateTrace_(),t}abortDrawing(){const t=this.abortDrawing_();t&&this.dispatchEvent(new F(D.DRAWABORT,t))}appendCoordinates(t){const e=this.mode_,i=!this.sketchFeature_;i&&this.startDrawing_(t[0]);let s;if(e==="LineString"||e==="Circle")s=this.sketchCoords_;else if(e==="Polygon")s=this.sketchCoords_&&this.sketchCoords_.length?this.sketchCoords_[0]:[];else return;i&&s.shift(),s.pop();for(let n=0;n<t.length;n++)this.addToDrawing_(t[n]);const o=t[t.length-1];this.sketchFeature_=this.addToDrawing_(o),this.modifyDrawing_(o)}extend(t){const i=t.getGeometry();this.sketchFeature_=t,this.sketchCoords_=i.getCoordinates();const s=this.sketchCoords_[this.sketchCoords_.length-1];this.finishCoordinate_=s.slice(),this.sketchCoords_.push(s.slice()),this.sketchPoint_=new k(new M(s)),this.updateSketchFeatures_(),this.dispatchEvent(new F(D.DRAWSTART,this.sketchFeature_))}updateSketchFeatures_(){const t=[];this.sketchFeature_&&t.push(this.sketchFeature_),this.sketchLine_&&t.push(this.sketchLine_),this.sketchPoint_&&t.push(this.sketchPoint_);const e=this.overlay_.getSource();e.clear(!0),e.addFeatures(t)}updateState_(){const t=this.getMap(),e=this.getActive();(!t||!e)&&this.abortDrawing(),this.overlay_.setMap(e?t:null)}}function gt(){const a=rt();return function(t,e){return a[t.getGeometry().getType()]}}function kt(){return function(a,t,e){const i=j([a[0],a[a.length-1]].map(function(o){return G(o)})),s=[[N(i),st(i),nt(i),ot(i),N(i)]];return t?t.setCoordinates(s):t=new R(s),t}}function pt(a){switch(a){case"Point":case"MultiPoint":return"Point";case"LineString":case"MultiLineString":return"LineString";case"Polygon":case"MultiPolygon":return"Polygon";case"Circle":return"Circle";default:throw new Error("Invalid type: "+a)}}export{yt as D,kt as c};
