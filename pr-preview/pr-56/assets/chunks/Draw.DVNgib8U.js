import{q as A,L,M as U,P as R,r as q,G as X,s as j,u as K,v as z,x as J,y as Q,C as Y,z as G,A as $,e as Z,d as ee,E as te,B as V,h as k,H as M,I as v,J as ie,K as N,N as se,Q as ne,R as oe,U as re,X as ae}from"./olcs.Cqh799zv.js";import{P as he,n as ce,a as E,s as O,I as le,b as p,c as de,d as _e}from"./Map.hMK3qLcu.js";function m(a,e){const t=a.length;return e<0?a[e+t]:e>=t?a[e-t]:a[e]}function y(a,e){const t=a.length;let i=Math.floor(e);const s=e-i;i>=t?i-=t:i<0&&(i+=t);let o=i+1;o>=t&&(o-=t);const n=a[i],r=n[0],h=n[1],c=a[o],_=c[0]-r,l=c[1]-h;return[r+_*s,h+l*s]}const T={index:-1,endIndex:NaN,closestTargetDistance:1/0};function fe(a,e,t,i){const s=a[0],o=a[1];let n=1/0,r=-1,h=NaN;for(let l=0;l<e.targets.length;++l){const d=e.targets[l],f=d.coordinates;let u=1/0,g;for(let C=0;C<f.length-1;++C){const H=f[C],W=f[C+1],S=B(s,o,H,W);S.squaredDistance<u&&(u=S.squaredDistance,g=C+S.along)}u<n&&(n=u,d.ring&&e.targetIndex===l&&(d.endIndex>d.startIndex?g<d.startIndex&&(g+=f.length):d.endIndex<d.startIndex&&g>d.startIndex&&(g-=f.length)),h=g,r=l)}const c=e.targets[r];let _=c.ring;if(e.targetIndex===r&&_){const l=y(c.coordinates,h),d=t.getPixelFromCoordinate(l),f=t.getPixelFromCoordinate(e.startCoord);A(d,f)>i&&(_=!1)}if(_){const l=c.coordinates,d=l.length,f=c.startIndex,u=h;if(f<u){const g=x(l,f,u);x(l,f,u-d)<g&&(h-=d)}else{const g=x(l,f,u);x(l,f,u+d)<g&&(h+=d)}}return T.index=r,T.endIndex=h,T.closestTargetDistance=n,T}function ue(a,e){const t=[];for(let i=0;i<e.length;++i){const o=e[i].getGeometry();b(a,o,t)}return t}function b(a,e,t){if(e instanceof L){P(a,e.getCoordinates(),!1,t);return}if(e instanceof U){const i=e.getCoordinates();for(let s=0,o=i.length;s<o;++s)P(a,i[s],!1,t);return}if(e instanceof R){const i=e.getCoordinates();for(let s=0,o=i.length;s<o;++s)P(a,i[s],!0,t);return}if(e instanceof q){const i=e.getCoordinates();for(let s=0,o=i.length;s<o;++s){const n=i[s];for(let r=0,h=n.length;r<h;++r)P(a,n[r],!0,t)}return}if(e instanceof X){const i=e.getGeometries();for(let s=0;s<i.length;++s)b(a,i[s],t);return}}function P(a,e,t,i){const s=a[0],o=a[1];for(let n=0,r=e.length-1;n<r;++n){const h=e[n],c=e[n+1],_=B(s,o,h,c);if(_.squaredDistance===0){const l=n+_.along;i.push({coordinates:e,ring:t,startIndex:l,endIndex:l});return}}}function w(a,e){return j(a[0],a[1],e[0],e[1])}function x(a,e,t){let i,s;e<t?(i=e,s=t):(i=t,s=e);const o=Math.ceil(i),n=Math.floor(s);if(o>n){const h=y(a,i),c=y(a,s);return w(h,c)}let r=0;if(i<o){const h=y(a,i),c=m(a,o);r+=w(h,c)}if(n<s){const h=m(a,n),c=y(a,s);r+=w(h,c)}for(let h=o;h<n-1;++h){const c=m(a,h),_=m(a,h+1);r+=w(c,_)}return r}const I={along:0,squaredDistance:0};function B(a,e,t,i){const s=t[0],o=t[1],n=i[0],r=i[1],h=n-s,c=r-o;let _=0,l=s,d=o;return(h!==0||c!==0)&&(_=z(((a-s)*h+(e-o)*c)/(h*h+c*c),0,1),l+=h*_,d+=c*_),I.along=_,I.squaredDistance=K(j(a,e,l,d),10),I}const D={DRAWSTART:"drawstart",DRAWEND:"drawend",DRAWABORT:"drawabort"};class F extends ae{constructor(e,t){super(e),this.feature=t}}class ye extends he{constructor(e){const t=e;t.stopDown||(t.stopDown=J),super(t),this.on,this.once,this.un,this.options_=e,this.shouldHandle_=!1,this.downPx_=null,this.downTimeout_,this.lastDragTime_,this.pointerType_,this.freehand_=!1,this.source_=e.source?e.source:null,this.features_=e.features?e.features:null,this.snapTolerance_=e.snapTolerance?e.snapTolerance:12,this.type_=e.type,this.mode_=pe(this.type_),this.stopClick_=!!e.stopClick,this.ignoreNextUpEvent_=!1,this.minPoints_=e.minPoints?e.minPoints:this.mode_==="Polygon"?3:2,this.maxPoints_=this.mode_==="Circle"?2:e.maxPoints?e.maxPoints:1/0,this.finishCondition_=e.finishCondition?e.finishCondition:Q,this.geometryLayout_=e.geometryLayout?e.geometryLayout:"XY";let i=e.geometryFunction;if(!i){const s=this.mode_;if(s==="Circle")i=(o,n,r)=>{const h=n||new Y([NaN,NaN]),c=G(o[0]),_=$(c,G(o[o.length-1]));return h.setCenterAndRadius(c,Math.sqrt(_),this.geometryLayout_),h};else{let o;s==="Point"?o=M:s==="LineString"?o=L:s==="Polygon"&&(o=R),i=(n,r,h)=>(r?s==="Polygon"?n[0].length?r.setCoordinates([n[0].concat([n[0][0]])],this.geometryLayout_):r.setCoordinates([],this.geometryLayout_):r.setCoordinates(n,this.geometryLayout_):r=new o(n,this.geometryLayout_),r)}}this.geometryFunction_=i,this.dragVertexDelay_=e.dragVertexDelay!==void 0?e.dragVertexDelay:500,this.finishCoordinate_=null,this.sketchFeature_=null,this.sketchPoint_=null,this.sketchCoords_=null,this.sketchLine_=null,this.sketchLineCoords_=null,this.squaredClickTolerance_=e.clickTolerance?e.clickTolerance*e.clickTolerance:36,this.overlay_=new Z({source:new ee({useSpatialIndex:!1,wrapX:e.wrapX?e.wrapX:!1}),style:e.style?e.style:ge(),updateWhileInteracting:!0}),this.geometryName_=e.geometryName,this.condition_=e.condition?e.condition:ce,this.freehandCondition_,e.freehand?this.freehandCondition_=E:this.freehandCondition_=e.freehandCondition?e.freehandCondition:O,this.traceCondition_,this.setTrace(e.trace||!1),this.traceState_={active:!1},this.traceSource_=e.traceSource||e.source||null,this.addChangeListener(le.ACTIVE,this.updateState_)}setTrace(e){let t;e?e===!0?t=E:t=e:t=_e,this.traceCondition_=t}setMap(e){super.setMap(e),this.updateState_()}setFreehand(e){this.freehand_=e,this.freehand_?this.freehandCondition_=E:this.freehandCondition_=this.options_&&this.options_.freehandCondition?this.options_.freehandCondition:O}getOverlay(){return this.overlay_}getFreehand(){return this.freehand_}handleEvent(e){e.originalEvent.type===te.CONTEXTMENU&&e.originalEvent.preventDefault(),this.freehand_=this.mode_!=="Point"&&this.freehandCondition_(e);let t=e.type===p.POINTERMOVE,i=!0;return!this.freehand_&&this.lastDragTime_&&e.type===p.POINTERDRAG&&(Date.now()-this.lastDragTime_>=this.dragVertexDelay_?(this.downPx_=e.pixel,this.shouldHandle_=!this.freehand_,t=!0):this.lastDragTime_=void 0,this.shouldHandle_&&this.downTimeout_!==void 0&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0)),this.freehand_&&e.type===p.POINTERDRAG&&this.sketchFeature_!==null?(this.addToDrawing_(e.coordinate),i=!1):this.freehand_&&e.type===p.POINTERDOWN?i=!1:t&&this.getPointerCount()<2?(i=e.type===p.POINTERMOVE,i&&this.freehand_?(this.handlePointerMove_(e),this.shouldHandle_&&e.originalEvent.preventDefault()):(e.originalEvent.pointerType==="mouse"||e.type===p.POINTERDRAG&&this.downTimeout_===void 0)&&this.handlePointerMove_(e)):e.type===p.DBLCLICK&&(i=!1),super.handleEvent(e)&&i}handleDownEvent(e){return this.shouldHandle_=!this.freehand_,this.freehand_?(this.downPx_=e.pixel,this.finishCoordinate_||this.startDrawing_(e.coordinate),!0):this.condition_(e)?(this.lastDragTime_=Date.now(),this.downTimeout_=setTimeout(()=>{this.handlePointerMove_(new de(p.POINTERMOVE,e.map,e.originalEvent,!1,e.frameState))},this.dragVertexDelay_),this.downPx_=e.pixel,!0):(this.lastDragTime_=void 0,!1)}deactivateTrace_(){this.traceState_={active:!1}}toggleTraceState_(e){if(!this.traceSource_||!this.traceCondition_(e))return;if(this.traceState_.active){this.deactivateTrace_();return}const t=this.getMap(),i=t.getCoordinateFromPixel([e.pixel[0]-this.snapTolerance_,e.pixel[1]+this.snapTolerance_]),s=t.getCoordinateFromPixel([e.pixel[0]+this.snapTolerance_,e.pixel[1]-this.snapTolerance_]),o=V([i,s]),n=this.traceSource_.getFeaturesInExtent(o);if(n.length===0)return;const r=ue(e.coordinate,n);r.length&&(this.traceState_={active:!0,startCoord:e.coordinate.slice(),targets:r,targetIndex:-1})}addOrRemoveTracedCoordinates_(e,t){const i=e.startIndex<=e.endIndex,s=e.startIndex<=t;i===s?i&&t>e.endIndex||!i&&t<e.endIndex?this.addTracedCoordinates_(e,e.endIndex,t):(i&&t<e.endIndex||!i&&t>e.endIndex)&&this.removeTracedCoordinates_(t,e.endIndex):(this.removeTracedCoordinates_(e.startIndex,e.endIndex),this.addTracedCoordinates_(e,e.startIndex,t))}removeTracedCoordinates_(e,t){if(e===t)return;let i=0;if(e<t){const s=Math.ceil(e);let o=Math.floor(t);o===t&&(o-=1),i=o-s+1}else{const s=Math.floor(e);let o=Math.ceil(t);o===t&&(o+=1),i=s-o+1}i>0&&this.removeLastPoints_(i)}addTracedCoordinates_(e,t,i){if(t===i)return;const s=[];if(t<i){const o=Math.ceil(t);let n=Math.floor(i);n===i&&(n-=1);for(let r=o;r<=n;++r)s.push(m(e.coordinates,r))}else{const o=Math.floor(t);let n=Math.ceil(i);n===i&&(n+=1);for(let r=o;r>=n;--r)s.push(m(e.coordinates,r))}s.length&&this.appendCoordinates(s)}updateTrace_(e){const t=this.traceState_;if(!t.active)return;if(t.targetIndex===-1){const r=e.map.getPixelFromCoordinate(t.startCoord);if(A(r,e.pixel)<this.snapTolerance_)return}const i=fe(e.coordinate,t,this.getMap(),this.snapTolerance_);if(t.targetIndex!==i.index){if(t.targetIndex!==-1){const h=t.targets[t.targetIndex];this.removeTracedCoordinates_(h.startIndex,h.endIndex)}const r=t.targets[i.index];this.addTracedCoordinates_(r,r.startIndex,i.endIndex)}else{const r=t.targets[t.targetIndex];this.addOrRemoveTracedCoordinates_(r,i.endIndex)}t.targetIndex=i.index;const s=t.targets[t.targetIndex];s.endIndex=i.endIndex;const o=y(s.coordinates,s.endIndex),n=this.getMap().getPixelFromCoordinate(o);e.coordinate=o,e.pixel=[Math.round(n[0]),Math.round(n[1])]}handleDragEvent(e){this.ignoreNextUpEvent_=!0,super.handleDragEvent(e)}handleUpEvent(e){let t=!0;if(this.getPointerCount()===0){this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0),this.handlePointerMove_(e);const i=this.traceState_.active;if(this.ignoreNextUpEvent_||this.toggleTraceState_(e),this.shouldHandle_){const s=!this.finishCoordinate_;s&&this.startDrawing_(e.coordinate),!s&&this.freehand_?this.finishDrawing():!this.freehand_&&(!s||this.mode_==="Point")&&(this.atFinish_(e.pixel,i)?this.finishCondition_(e)&&this.finishDrawing():this.addToDrawing_(e.coordinate)),t=!1}else this.freehand_&&this.abortDrawing()}return this.ignoreNextUpEvent_=!1,!t&&this.stopClick_&&e.preventDefault(),t}handlePointerMove_(e){if(this.pointerType_=e.originalEvent.pointerType,this.downPx_&&(!this.freehand_&&this.shouldHandle_||this.freehand_&&!this.shouldHandle_)){const t=this.downPx_,i=e.pixel,s=t[0]-i[0],o=t[1]-i[1],n=s*s+o*o;if(this.shouldHandle_=this.freehand_?n>this.squaredClickTolerance_:n<=this.squaredClickTolerance_,!this.shouldHandle_)return}if(!this.finishCoordinate_){this.createOrUpdateSketchPoint_(e.coordinate.slice());return}this.updateTrace_(e),this.modifyDrawing_(e.coordinate)}atFinish_(e,t){let i=!1;if(this.sketchFeature_){let s=!1,o=[this.finishCoordinate_];const n=this.mode_;if(n==="Point")i=!0;else if(n==="Circle")i=this.sketchCoords_.length===2;else if(n==="LineString")s=!t&&this.sketchCoords_.length>this.minPoints_;else if(n==="Polygon"){const r=this.sketchCoords_;s=r[0].length>this.minPoints_,o=[r[0][0],r[0][r[0].length-2]],t?o=[r[0][0]]:o=[r[0][0],r[0][r[0].length-2]]}if(s){const r=this.getMap();for(let h=0,c=o.length;h<c;h++){const _=o[h],l=r.getPixelFromCoordinate(_),d=e[0]-l[0],f=e[1]-l[1],u=this.freehand_?1:this.snapTolerance_;if(i=Math.sqrt(d*d+f*f)<=u,i){this.finishCoordinate_=_;break}}}}return i}createOrUpdateSketchPoint_(e){this.sketchPoint_?this.sketchPoint_.getGeometry().setCoordinates(e):(this.sketchPoint_=new k(new M(e)),this.updateSketchFeatures_())}createOrUpdateCustomSketchLine_(e){this.sketchLine_||(this.sketchLine_=new k);const t=e.getLinearRing(0);let i=this.sketchLine_.getGeometry();i?(i.setFlatCoordinates(t.getLayout(),t.getFlatCoordinates()),i.changed()):(i=new L(t.getFlatCoordinates(),t.getLayout()),this.sketchLine_.setGeometry(i))}startDrawing_(e){const t=this.getMap().getView().getProjection(),i=v(this.geometryLayout_);for(;e.length<i;)e.push(0);this.finishCoordinate_=e,this.mode_==="Point"?this.sketchCoords_=e.slice():this.mode_==="Polygon"?(this.sketchCoords_=[[e.slice(),e.slice()]],this.sketchLineCoords_=this.sketchCoords_[0]):this.sketchCoords_=[e.slice(),e.slice()],this.sketchLineCoords_&&(this.sketchLine_=new k(new L(this.sketchLineCoords_)));const s=this.geometryFunction_(this.sketchCoords_,void 0,t);this.sketchFeature_=new k,this.geometryName_&&this.sketchFeature_.setGeometryName(this.geometryName_),this.sketchFeature_.setGeometry(s),this.updateSketchFeatures_(),this.dispatchEvent(new F(D.DRAWSTART,this.sketchFeature_))}modifyDrawing_(e){const t=this.getMap(),i=this.sketchFeature_.getGeometry(),s=t.getView().getProjection(),o=v(this.geometryLayout_);let n,r;for(;e.length<o;)e.push(0);this.mode_==="Point"?r=this.sketchCoords_:this.mode_==="Polygon"?(n=this.sketchCoords_[0],r=n[n.length-1],this.atFinish_(t.getPixelFromCoordinate(e))&&(e=this.finishCoordinate_.slice())):(n=this.sketchCoords_,r=n[n.length-1]),r[0]=e[0],r[1]=e[1],this.geometryFunction_(this.sketchCoords_,i,s),this.sketchPoint_&&this.sketchPoint_.getGeometry().setCoordinates(e),i.getType()==="Polygon"&&this.mode_!=="Polygon"?this.createOrUpdateCustomSketchLine_(i):this.sketchLineCoords_&&this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_),this.updateSketchFeatures_()}addToDrawing_(e){const t=this.sketchFeature_.getGeometry(),i=this.getMap().getView().getProjection();let s,o;const n=this.mode_;return n==="LineString"||n==="Circle"?(this.finishCoordinate_=e.slice(),o=this.sketchCoords_,o.length>=this.maxPoints_&&(this.freehand_?o.pop():s=!0),o.push(e.slice()),this.geometryFunction_(o,t,i)):n==="Polygon"&&(o=this.sketchCoords_[0],o.length>=this.maxPoints_&&(this.freehand_?o.pop():s=!0),o.push(e.slice()),s&&(this.finishCoordinate_=o[0]),this.geometryFunction_(this.sketchCoords_,t,i)),this.createOrUpdateSketchPoint_(e.slice()),this.updateSketchFeatures_(),s?this.finishDrawing():this.sketchFeature_}removeLastPoints_(e){if(!this.sketchFeature_)return;const t=this.sketchFeature_.getGeometry(),i=this.getMap().getView().getProjection(),s=this.mode_;for(let o=0;o<e;++o){let n;if(s==="LineString"||s==="Circle"){if(n=this.sketchCoords_,n.splice(-2,1),n.length>=2){this.finishCoordinate_=n[n.length-2].slice();const r=this.finishCoordinate_.slice();n[n.length-1]=r,this.createOrUpdateSketchPoint_(r)}this.geometryFunction_(n,t,i),t.getType()==="Polygon"&&this.sketchLine_&&this.createOrUpdateCustomSketchLine_(t)}else if(s==="Polygon"){n=this.sketchCoords_[0],n.splice(-2,1);const r=this.sketchLine_.getGeometry();if(n.length>=2){const h=n[n.length-2].slice();n[n.length-1]=h,this.createOrUpdateSketchPoint_(h)}r.setCoordinates(n),this.geometryFunction_(this.sketchCoords_,t,i)}if(n.length===1){this.abortDrawing();break}}this.updateSketchFeatures_()}removeLastPoint(){this.removeLastPoints_(1)}finishDrawing(){const e=this.abortDrawing_();if(!e)return null;let t=this.sketchCoords_;const i=e.getGeometry(),s=this.getMap().getView().getProjection();return this.mode_==="LineString"?(t.pop(),this.geometryFunction_(t,i,s)):this.mode_==="Polygon"&&(t[0].pop(),this.geometryFunction_(t,i,s),t=i.getCoordinates()),this.type_==="MultiPoint"?e.setGeometry(new ie([t])):this.type_==="MultiLineString"?e.setGeometry(new U([t])):this.type_==="MultiPolygon"&&e.setGeometry(new q([t])),this.dispatchEvent(new F(D.DRAWEND,e)),this.features_&&this.features_.push(e),this.source_&&this.source_.addFeature(e),e}abortDrawing_(){this.finishCoordinate_=null;const e=this.sketchFeature_;return this.sketchFeature_=null,this.sketchPoint_=null,this.sketchLine_=null,this.overlay_.getSource().clear(!0),this.deactivateTrace_(),e}abortDrawing(){const e=this.abortDrawing_();e&&this.dispatchEvent(new F(D.DRAWABORT,e))}appendCoordinates(e){const t=this.mode_,i=!this.sketchFeature_;i&&this.startDrawing_(e[0]);let s;if(t==="LineString"||t==="Circle")s=this.sketchCoords_;else if(t==="Polygon")s=this.sketchCoords_&&this.sketchCoords_.length?this.sketchCoords_[0]:[];else return;i&&s.shift(),s.pop();for(let n=0;n<e.length;n++)this.addToDrawing_(e[n]);const o=e[e.length-1];this.sketchFeature_=this.addToDrawing_(o),this.modifyDrawing_(o)}extend(e){const i=e.getGeometry();this.sketchFeature_=e,this.sketchCoords_=i.getCoordinates();const s=this.sketchCoords_[this.sketchCoords_.length-1];this.finishCoordinate_=s.slice(),this.sketchCoords_.push(s.slice()),this.sketchPoint_=new k(new M(s)),this.updateSketchFeatures_(),this.dispatchEvent(new F(D.DRAWSTART,this.sketchFeature_))}updateSketchFeatures_(){const e=[];this.sketchFeature_&&e.push(this.sketchFeature_),this.sketchLine_&&e.push(this.sketchLine_),this.sketchPoint_&&e.push(this.sketchPoint_);const t=this.overlay_.getSource();t.clear(!0),t.addFeatures(e)}updateState_(){const e=this.getMap(),t=this.getActive();(!e||!t)&&this.abortDrawing(),this.overlay_.setMap(t?e:null)}}function ge(){const a=re();return function(e,t){return a[e.getGeometry().getType()]}}function ke(){return function(a,e,t){const i=V([a[0],a[a.length-1]].map(function(o){return G(o)})),s=[[N(i),se(i),ne(i),oe(i),N(i)]];return e?e.setCoordinates(s):e=new R(s),e}}function pe(a){switch(a){case"Point":case"MultiPoint":return"Point";case"LineString":case"MultiLineString":return"LineString";case"Polygon":case"MultiPolygon":return"Polygon";case"Circle":return"Circle";default:throw new Error("Invalid type: "+a)}}export{ye as D,ke as c};
