import{D as S,i as k,j as E,k as L,l as $,m as A,W as R,p as B}from"./olcs.2jv08wJ5.js";import{F,o as M,g as D,s as y}from"./open.3dSSKp8v.js";const N=["d35379db-88df-4056-af3a-620245f8e347","f17cb550-5864-4468-aeb7-f3180cfb622f","689b58e2-cf7b-45e0-9fff-9cfc0883d6b4"];class W extends S{constructor(t){super({state:"loading",tileGrid:null,projection:t.projection||null,transition:t.transition,wrapX:t.wrapX}),this.url_=t.url,this.group_=t.group,this.error_=null,this.root_=null,this.consolidatedMetadata_=null,this.bands_=t.bands,this.bandsByLevel_=null,this.fillValue_,this.resampleMethod_=t.resample||"linear",this.bandCount=this.bands_.length,this.setLoader(this.loadTile_.bind(this)),this.tileGrid,this.configure_().then(()=>{this.setState("ready")}).catch(c=>{this.error_=c,this.setState("error")})}async configure_(){const t=new F(this.url_);this.root_=await M(t,{kind:"group"});try{this.consolidatedMetadata_=JSON.parse(new TextDecoder().decode(await t.get(this.root_.resolve("zarr.json").path))).consolidated_metadata.metadata}catch{}const r=(await M(this.root_.resolve(this.group_),{kind:"group"})).attrs;if("zarr_conventions"in r&&Array.isArray(r.zarr_conventions)&&N.every(a=>r.zarr_conventions.find(s=>s.uuid===a))&&"layout"in r.multiscales){const{tileGrid:a,projection:s,bandsByLevel:i,fillValue:n}=O(r,this.consolidatedMetadata_,this.group_,this.bands_);this.bandsByLevel_=i,this.tileGrid=a,this.projection=s,this.fillValue_=n}else if("tile_matrix_set"in r.multiscales){const{tileGrid:a,projection:s}=z(r);this.tileGrid=a,this.projection=s}const g=this.tileGrid.getExtent();setTimeout(()=>{this.viewResolver({showFullExtent:!0,projection:this.projection,resolutions:this.tileGrid.getResolutions(),center:E(L(g),this.projection),extent:k(g,this.projection),zoom:1})})}async loadTile_(t,c,r,g){const a=this.tileGrid.getResolutions(),s=this.tileGrid.getResolution(t),i=this.tileGrid.getTileCoordExtent([t,c,r]),n=[],o=[];for(const m of this.bands_){let h,l,f=0;if(!this.bandsByLevel_)h=this.tileGrid.getMatrixId(t),l=s,f=t;else for(let x=0;x<a.length;x+=1){const T=a[x];if(h&&T<s)break;const v=this.tileGrid.getMatrixId(x);this.bandsByLevel_[v].includes(m)&&(h=v,l=this.tileGrid.getResolution(x),f=x)}if(!h||!l)throw new Error(`Could not find available resolution for band ${m}`);const _=this.tileGrid.getOrigin(f),b=Math.round((i[0]-_[0])/l),w=Math.round((i[2]-_[0])/l),G=Math.round((_[1]-i[3])/l),j=Math.round((_[1]-i[1])/l),I=`${this.group_}/${h}/${m}`,C=await M(this.root_.resolve(I),{kind:"array"});n.push(D(C,[y(G,j),y(b,w)])),o.push(l)}const d=await Promise.all(n),[e,u]=$(this.tileGrid.getTileSize(t));return V(d,o,e,u,s,this.resampleMethod_,this.fillValue_||0)}}function O(p,t,c,r){const g=p.multiscales,a=p["spatial:bbox"],s=A(p["proj:code"]),i=[],n=t?{}:null;let o;for(const e of g.layout){const u=e["spatial:transform"],m=u[0],h=[u[2],u[5]],l=e.asset;if(i.push({matrixId:l,resolution:m,origin:h}),t){const f=[];for(const _ of r){const b=t[`${c}/${l}/${_}`];b&&(f.push(_),o===void 0&&(o=b.fill_value))}n[l]=f}}return i.sort((e,u)=>u.resolution-e.resolution),{tileGrid:new R({extent:a,origins:i.map(e=>e.origin),resolutions:i.map(e=>e.resolution),matrixIds:i.map(e=>e.matrixId)}),projection:s,bandsByLevel:n,fillValue:o}}function z(p){const t=p.multiscales,c=t.tile_matrix_set,r=t.tile_matrix_limits,g=c.tileMatrices.length,a=new Array(g);let s=!1;for(let o=0;o<g;o+=1){const d=c.tileMatrices[o],e=d.id;(d.tileWidth>512||d.tileHeight>512)&&(s=!0),a[o]=r[e]}const i=B({},c,void 0,a);let n=i.grid;return s&&(n=new R({tileSize:512,extent:n.getExtent(),origins:n.getOrigins(),resolutions:n.getResolutions(),matrixIds:n.getMatrixIds()})),{tileGrid:n,projection:i.projection}}function V(p,t,c,r,g,a,s){const i=p.length,n=new Float32Array(c*r*i);for(let o=0;o<r;o++)for(let d=0;d<c;d++)for(let e=0;e<i;++e){const u=p[e],m=u.shape[0],h=u.shape[1],l=g/t[e];let f=s;if(l===1)o<m&&d<h&&(f=u.data[o*h+d]);else{const _=o*l,b=d*l;switch(a){case"nearest":{const w=Math.round(_),G=Math.round(b);w<m&&G<h&&(f=u.data[w*h+G]);break}default:throw new Error(`Unsupported resample method: ${a}`)}}isNaN(f)&&(f=s),n[i*(o*c+d)+e]=f}return n}export{W as G};
