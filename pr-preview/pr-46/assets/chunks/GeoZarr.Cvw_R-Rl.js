const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/chunks/blosc.nNxqTOai.js","assets/chunks/chunk-INHXZS53.D3tQiqtZ.js","assets/chunks/lz4.COuoZ_ur.js","assets/chunks/zstd.CtzXwP91.js"])))=>i.map(i=>d[i]);
var ce=Object.defineProperty;var $t=e=>{throw TypeError(e)};var le=(e,t,n)=>t in e?ce(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var g=(e,t,n)=>le(e,typeof t!="symbol"?t+"":t,n),ht=(e,t,n)=>t.has(e)||$t("Cannot "+n);var _=(e,t,n)=>(ht(e,t,"read from private field"),n?n.call(e):t.get(e)),x=(e,t,n)=>t.has(e)?$t("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,n),w=(e,t,n,r)=>(ht(e,t,"write to private field"),r?r.call(e,n):t.set(e,n),n),ft=(e,t,n)=>(ht(e,t,"access private method"),n);import{aX as yt,Q as ue,bd as de,be as he,bf as fe,G as _e}from"./XYZ.8i23LU2V.js";import{a as vt,D as pe}from"./DataTile.CjqBuOpj.js";import{a5 as _t}from"./framework.DGE5n9zZ.js";function te(e,t,n,r={}){return t!==void 0&&n!==void 0&&(r={...r,headers:{...r.headers,Range:`bytes=${t}-${t+n-1}`}}),fetch(e,r)}function ye(e,t){return{...e,...t,headers:{...e.headers,...t.headers}}}function Gt(e,t){const n=typeof e=="string"?new URL(e):e;n.pathname.endsWith("/")||(n.pathname+="/");const r=new URL(t.slice(1),n);return r.search=n.search,r}async function Bt(e){if(e.status!==404){if(e.status===200||e.status===206)return new Uint8Array(await e.arrayBuffer());throw new Error(`Unexpected response status ${e.status} ${e.statusText}`)}}async function ge(e,t,n,r){if(r)return fetch(e,{...n,headers:{...n.headers,Range:`bytes=-${t}`}});let i=await fetch(e,{...n,method:"HEAD"});if(!i.ok)return i;let s=i.headers.get("Content-Length"),o=Number(s);return te(e,o-t,o,n)}var F,D,Y,gt;class me{constructor(t,n={}){x(this,Y);g(this,"url");x(this,F);x(this,D);this.url=t,w(this,F,n.overrides??{}),w(this,D,n.useSuffixRequest??!1)}async get(t,n={}){let r=Gt(this.url,t).href,i=await fetch(r,ft(this,Y,gt).call(this,n));return Bt(i)}async getRange(t,n,r={}){let i=Gt(this.url,t),s=ft(this,Y,gt).call(this,r),o;return"suffixLength"in n?o=await ge(i,n.suffixLength,s,_(this,D)):o=await te(i,n.offset,n.length,s),Bt(o)}}F=new WeakMap,D=new WeakMap,Y=new WeakSet,gt=function(t){return ye(_(this,F),t)};var R;class ee{constructor(t,n,r){x(this,R);typeof t=="number"?w(this,R,new Uint8Array(t)):t instanceof ArrayBuffer?w(this,R,new Uint8Array(t,n,r)):w(this,R,new Uint8Array(Array.from(t,i=>i?1:0)))}get BYTES_PER_ELEMENT(){return 1}get byteOffset(){return _(this,R).byteOffset}get byteLength(){return _(this,R).byteLength}get buffer(){return _(this,R).buffer}get length(){return _(this,R).length}get(t){let n=_(this,R)[t];return typeof n=="number"?n!==0:n}set(t,n){_(this,R)[t]=n?1:0}fill(t){_(this,R).fill(t?1:0)}*[Symbol.iterator](){for(let t=0;t<this.length;t++)yield this.get(t)}}R=new WeakMap;var j;class xt{constructor(t,n,r,i){g(this,"_data");g(this,"chars");x(this,j);if(this.chars=t,w(this,j,new TextEncoder),typeof n=="number")this._data=new Uint8Array(n*t);else if(n instanceof ArrayBuffer)i&&(i=i*t),this._data=new Uint8Array(n,r,i);else{let s=Array.from(n);this._data=new Uint8Array(s.length*t);for(let o=0;o<s.length;o++)this.set(o,s[o])}}get BYTES_PER_ELEMENT(){return this.chars}get byteOffset(){return this._data.byteOffset}get byteLength(){return this._data.byteLength}get buffer(){return this._data.buffer}get length(){return this.byteLength/this.BYTES_PER_ELEMENT}get(t){const n=new Uint8Array(this.buffer,this.byteOffset+this.chars*t,this.chars);return new TextDecoder().decode(n).replace(/\x00/g,"")}set(t,n){const r=new Uint8Array(this.buffer,this.byteOffset+this.chars*t,this.chars);r.fill(0),r.set(_(this,j).encode(n))}fill(t){const n=_(this,j).encode(t);for(let r=0;r<this.length;r++)this._data.set(n,r*this.chars)}*[Symbol.iterator](){for(let t=0;t<this.length;t++)yield this.get(t)}}j=new WeakMap;var I;const St=class St{constructor(t,n,r,i){x(this,I);g(this,"chars");if(this.chars=t,typeof n=="number")w(this,I,new Int32Array(n*t));else if(n instanceof ArrayBuffer)i&&(i*=t),w(this,I,new Int32Array(n,r,i));else{const s=n,o=new St(t,1);w(this,I,new Int32Array(function*(){for(let a of s)o.set(0,a),yield*_(o,I)}()))}}get BYTES_PER_ELEMENT(){return _(this,I).BYTES_PER_ELEMENT*this.chars}get byteLength(){return _(this,I).byteLength}get byteOffset(){return _(this,I).byteOffset}get buffer(){return _(this,I).buffer}get length(){return _(this,I).length/this.chars}get(t){const n=this.chars*t;let r="";for(let i=0;i<this.chars;i++)r+=String.fromCodePoint(_(this,I)[n+i]);return r.replace(/\u0000/g,"")}set(t,n){const r=this.chars*t,i=_(this,I).subarray(r,r+this.chars);i.fill(0);for(let s=0;s<this.chars;s++)i[s]=n.codePointAt(s)??0}fill(t){this.set(0,t);let n=_(this,I).subarray(0,this.chars);for(let r=1;r<this.length;r++)_(this,I).set(n,r*this.chars)}*[Symbol.iterator](){for(let t=0;t<this.length;t++)yield this.get(t)}};I=new WeakMap;let P=St;function tt(e){const t=new TextDecoder().decode(e);return JSON.parse(t)}function Pt(e,t){const n=t/2,r=t-1;let i=0;for(let s=0;s<e.length;s+=t)for(let o=0;o<n;o+=1)i=e[s+o],e[s+o]=e[s+r-o],e[s+r-o]=i}function ne(e){if(e==="v2:object")return globalThis.Array;let t=e.match(/v2:([US])(\d+)/);if(t){let[,r,i]=t;return(r==="U"?P:xt).bind(null,Number(i))}let n={int8:Int8Array,int16:Int16Array,int32:Int32Array,int64:globalThis.BigInt64Array,uint8:Uint8Array,uint16:Uint16Array,uint32:Uint32Array,uint64:globalThis.BigUint64Array,float16:globalThis.Float16Array,float32:Float32Array,float64:Float64Array,bool:ee}[e];return T(n,`Unknown or unsupported data_type: ${e}`),n}function U(e,t){const n=e.length;typeof t=="string"&&(t=t==="C"?Array.from({length:n},(s,o)=>o):Array.from({length:n},(s,o)=>n-1-o)),T(n===t.length,"Order length must match the number of dimensions.");let r=1,i=new Array(n);for(let s=t.length-1;s>=0;s--)i[t[s]]=r,r*=e[t[s]];return i}function be({name:e,configuration:t}){if(e==="default"){const n=(t==null?void 0:t.separator)??"/";return r=>["c",...r].join(n)}if(e==="v2"){const n=(t==null?void 0:t.separator)??".";return r=>r.join(n)||"0"}throw new Error(`Unknown chunk key encoding: ${e}`)}function we(e){if(e==="|O")return{data_type:"v2:object"};let t=e.match(/^([<|>])(.*)$/);T(t,`Invalid dtype: ${e}`);let[,n,r]=t,i={b1:"bool",i1:"int8",u1:"uint8",i2:"int16",u2:"uint16",i4:"int32",u4:"uint32",i8:"int64",u8:"uint64",f2:"float16",f4:"float32",f8:"float64"}[r]??(r.startsWith("S")||r.startsWith("U")?`v2:${r}`:void 0);return T(i,`Unsupported or unknown dtype: ${e}`),n==="|"?{data_type:i}:{data_type:i,endian:n==="<"?"little":"big"}}function ke(e,t={}){let n=[],r=we(e.dtype);e.order==="F"&&n.push({name:"transpose",configuration:{order:"F"}}),"endian"in r&&r.endian==="big"&&n.push({name:"bytes",configuration:{endian:"big"}});for(let{id:i,...s}of e.filters??[])n.push({name:i,configuration:s});if(e.compressor){let{id:i,...s}=e.compressor;n.push({name:i,configuration:s})}return{zarr_format:3,node_type:"array",shape:e.shape,data_type:r.data_type,chunk_grid:{name:"regular",configuration:{chunk_shape:e.chunks}},chunk_key_encoding:{name:"v2",configuration:{separator:e.dimension_separator??"."}},codecs:n,fill_value:e.fill_value,attributes:t}}function Ee(e,t={}){return{zarr_format:3,node_type:"group",attributes:t}}function ve(e,t){if(t!=="number"&&t!=="bigint"&&t!=="boolean"&&t!=="object"&&t!=="string")return e===t;let n=e==="bool";if(t==="boolean")return n;let r=e.startsWith("v2:U")||e.startsWith("v2:S");if(t==="string")return r;let i=e==="int64"||e==="uint64";if(t==="bigint")return i;let s=e==="v2:object";return t==="object"?s:!r&&!i&&!n&&!s}function xe(e){return(e==null?void 0:e.name)==="sharding_indexed"}function re(e){return(e.data_type==="uint64"||e.data_type==="int64")&&e.fill_value!=null?BigInt(e.fill_value):e.fill_value}function ie(e,...t){if(!t.some(n=>e instanceof n))throw e}function T(e,t=""){if(!e)throw new Error(t)}async function se(e,{format:t,signal:n}){const r=e instanceof Response?e:new Response(e);T(r.body,"Response does not contain body.");try{return await new Response(r.body.pipeThrough(new DecompressionStream(t),{signal:n})).arrayBuffer()}catch{throw n==null||n.throwIfAborted(),new Error(`Failed to decode ${t}`)}}class At{constructor(t,n){g(this,"kind","array_to_array");T(t.keepbits>=0,"keepbits must be zero or positive")}static fromConfig(t,n){return new At(t,n)}encode(t){throw new Error("`BitroundCodec.encode` is not implemented. Please open an issue at https://github.com/manzt/zarrita.js/issues.")}decode(t){return t}}const Ft=Ae();function Ae(){const e=new Uint32Array([305419896]);return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)[0]!==18}function Dt(e){return"BYTES_PER_ELEMENT"in e?e.BYTES_PER_ELEMENT:4}var W,S,J,V,z;const Ot=class Ot{constructor(t,n){g(this,"kind","array_to_bytes");x(this,W);x(this,S);x(this,J);x(this,V);x(this,z);w(this,z,t==null?void 0:t.endian),w(this,S,ne(n.data_type)),w(this,V,n.shape),w(this,W,U(n.shape,"C"));const r=new(_(this,S))(0);w(this,J,r.BYTES_PER_ELEMENT)}static fromConfig(t,n){return new Ot(t,n)}encode(t){let n=new Uint8Array(t.data.buffer);return Ft&&_(this,z)==="big"&&Pt(n,Dt(_(this,S))),n}decode(t){return Ft&&_(this,z)==="big"&&Pt(t,Dt(_(this,S))),{data:new(_(this,S))(t.buffer,t.byteOffset,t.byteLength/_(this,J)),shape:_(this,V),stride:_(this,W)}}};W=new WeakMap,S=new WeakMap,J=new WeakMap,V=new WeakMap,z=new WeakMap;let st=Ot;class Tt{constructor(){g(this,"kind","bytes_to_bytes")}static fromConfig(){return new Tt}encode(t){throw new Error("Not implemented")}decode(t){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength-4)}}class It{constructor(){g(this,"kind","bytes_to_bytes")}static fromConfig(t){return new It}encode(t){throw new Error("Gzip encoding is not enabled by default. Please register a custom codec with `numcodecs/gzip`.")}async decode(t){const n=await se(t,{format:"gzip"});return new Uint8Array(n)}}function Te(e,t){return T(!Number.isNaN(t),"JsonCodec allow_nan is false but NaN was encountered during encoding."),T(t!==Number.POSITIVE_INFINITY,"JsonCodec allow_nan is false but Infinity was encountered during encoding."),T(t!==Number.NEGATIVE_INFINITY,"JsonCodec allow_nan is false but -Infinity was encountered during encoding."),t}function Ie(e,t){return t instanceof Object&&!Array.isArray(t)?Object.keys(t).sort().reduce((n,r)=>(n[r]=t[r],n),{}):t}var X,H;const Ut=class Ut{constructor(t={}){g(this,"configuration");g(this,"kind","array_to_bytes");x(this,X);x(this,H);this.configuration=t;const{encoding:n="utf-8",skipkeys:r=!1,ensure_ascii:i=!0,check_circular:s=!0,allow_nan:o=!0,sort_keys:a=!0,indent:c,strict:u=!0}=t;let l=t.separators;l||(c?l=[", ",": "]:l=[",",":"]),w(this,X,{encoding:n,skipkeys:r,ensure_ascii:i,check_circular:s,allow_nan:o,indent:c,separators:l,sort_keys:a}),w(this,H,{strict:u})}static fromConfig(t){return new Ut(t)}encode(t){const{indent:n,encoding:r,ensure_ascii:i,check_circular:s,allow_nan:o,sort_keys:a}=_(this,X);T(r==="utf-8","JsonCodec does not yet support non-utf-8 encoding.");const c=[];T(s,"JsonCodec does not yet support skipping the check for circular references during encoding."),o||c.push(Te),a&&c.push(Ie);const u=Array.from(t.data);u.push("|O"),u.push(t.shape);let l;c.length&&(l=(h,p)=>{let b=p;for(let m of c)b=m(h,b);return b});let d=JSON.stringify(u,l,n);return i&&(d=d.replace(/[\u007F-\uFFFF]/g,h=>{const p=`0000${h.charCodeAt(0).toString(16)}`;return`\\u${p.substring(p.length-4)}`})),new TextEncoder().encode(d)}decode(t){const{strict:n}=_(this,H);T(n,"JsonCodec does not yet support non-strict decoding.");const r=tt(t),i=r.pop();r.pop(),T(i,"0D not implemented for JsonCodec.");const s=U(i,"C");return{data:r,shape:i,stride:s}}};X=new WeakMap,H=new WeakMap;let mt=Ut;function Yt(e){return e instanceof ee||e instanceof xt||e instanceof P?new Proxy(e,{get(n,r){return n.get(Number(r))},set(n,r,i){return n.set(Number(r),i),!0}}):e}function Re(e,t){let n;return e.data instanceof xt||e.data instanceof P?n=new e.constructor(e.data.length,e.data.chars):n=new e.constructor(e.data.length),{data:n,shape:e.shape,stride:U(e.shape,t)}}function Ne(e,t){let n=Re(e,t),r=e.shape.length,i=e.data.length,s=Array(r).fill(0),o=Yt(e.data),a=Yt(n.data);for(let c=0;c<i;c++){let u=0;for(let l=0;l<r;l++)u+=s[l]*n.stride[l];a[u]=o[c],s[0]+=1;for(let l=0;l<r;l++)if(s[l]===e.shape[l]){if(l+1===r)break;s[l]=0,s[l+1]+=1}}return n}function Ce(e){let t=e.shape.length;return T(t===e.stride.length,"Shape and stride must have the same length."),e.stride.map((n,r)=>({stride:n,index:r})).sort((n,r)=>r.stride-n.stride).map(n=>n.index)}function Le(e,t){let n=Ce(e);return T(n.length===t.length,"Orders must match"),n.every((r,i)=>r===t[i])}var Z,$;const jt=class jt{constructor(t,n){g(this,"kind","array_to_array");x(this,Z);x(this,$);let r=t.order??"C",i=n.shape.length,s=new Array(i),o=new Array(i);if(r==="C")for(let a=0;a<i;++a)s[a]=a,o[a]=a;else if(r==="F")for(let a=0;a<i;++a)s[a]=i-a-1,o[a]=i-a-1;else s=r,s.forEach((a,c)=>{T(o[a]===void 0,`Invalid permutation: ${JSON.stringify(r)}`),o[a]=c});w(this,Z,s),w(this,$,o)}static fromConfig(t,n){return new jt(t,n)}encode(t){return Le(t,_(this,$))?t:Ne(t,_(this,$))}decode(t){return{data:t.data,shape:t.shape,stride:U(t.shape,_(this,Z))}}};Z=new WeakMap,$=new WeakMap;let bt=jt;var K,Q;const zt=class zt{constructor(t){g(this,"kind","array_to_bytes");x(this,K);x(this,Q);w(this,K,t),w(this,Q,U(t,"C"))}static fromConfig(t,n){return new zt(n.shape)}encode(t){throw new Error("Method not implemented.")}decode(t){let n=new TextDecoder,r=new DataView(t.buffer),i=Array(r.getUint32(0,!0)),s=4;for(let o=0;o<i.length;o++){let a=r.getUint32(s,!0);s+=4,i[o]=n.decode(t.buffer.slice(s,s+a)),s+=a}return{data:i,shape:_(this,K),stride:_(this,Q)}}};K=new WeakMap,Q=new WeakMap;let wt=zt;class Rt{constructor(){g(this,"kind","bytes_to_bytes")}static fromConfig(t){return new Rt}encode(t){throw new Error("Zlib encoding is not enabled by default. Please register a codec with `numcodecs/zlib`.")}async decode(t){const n=await se(t,{format:"deflate"});return new Uint8Array(n)}}function Me(){return new Map().set("blosc",()=>_t(()=>import("./blosc.nNxqTOai.js"),__vite__mapDeps([0,1])).then(e=>e.default)).set("lz4",()=>_t(()=>import("./lz4.COuoZ_ur.js"),__vite__mapDeps([2,1])).then(e=>e.default)).set("zstd",()=>_t(()=>import("./zstd.CtzXwP91.js"),__vite__mapDeps([3,1])).then(e=>e.default)).set("gzip",()=>It).set("zlib",()=>Rt).set("transpose",()=>bt).set("bytes",()=>st).set("crc32c",()=>Tt).set("vlen-utf8",()=>wt).set("json2",()=>mt).set("bitround",()=>At)}const Se=Me();function kt(e){let t;return{async encode(n){t||(t=await Wt(e));for(const i of t.array_to_array)n=await i.encode(n);let r=await t.array_to_bytes.encode(n);for(const i of t.bytes_to_bytes)r=await i.encode(r);return r},async decode(n){t||(t=await Wt(e));for(let i=t.bytes_to_bytes.length-1;i>=0;i--)n=await t.bytes_to_bytes[i].decode(n);let r=await t.array_to_bytes.decode(n);for(let i=t.array_to_array.length-1;i>=0;i--)r=await t.array_to_array[i].decode(r);return r}}}async function Wt(e){let t=e.codecs.map(async s=>{var a;let o=await((a=Se.get(s.name))==null?void 0:a());return T(o,`Unknown codec: ${s.name}`),{Codec:o,meta:s}}),n=[],r,i=[];for await(let{Codec:s,meta:o}of t){let a=s.fromConfig(o.configuration,e);switch(a.kind){case"array_to_array":n.push(a);break;case"array_to_bytes":r=a;break;default:i.push(a)}}return r||(T(Oe(e),`Cannot encode ${e.data_type} to bytes without a codec`),r=st.fromConfig({endian:"little"},e)),{array_to_array:n,array_to_bytes:r,bytes_to_bytes:i}}function Oe(e){return e.data_type!=="v2:object"}class et extends Error{constructor(t,n={}){super(`Node not found: ${t}`,n),this.name="NodeNotFoundError"}}class Nt extends Error{constructor(t){super(`Missing key: ${t}`),this.name="KeyError"}}const Jt=18446744073709551615n;function Ue(e,t,n,r){T(e.store.getRange,"Store does not support range requests");let i=e.store.getRange.bind(e.store),s=t.map((c,u)=>c/r.chunk_shape[u]),o=kt({data_type:"uint64",shape:[...s,2],codecs:r.index_codecs}),a={};return async c=>{let u=c.map((v,f)=>Math.floor(v/s[f])),l=e.resolve(n(u)).path,d;if(l in a)d=a[l];else{let v=4,f=16*s.reduce((A,C)=>A*C,1),E=await i(l,{suffixLength:f+v});d=a[l]=E?await o.decode(E):null}if(d===null)return;let{data:h,shape:p,stride:b}=d,m=c.map((v,f)=>v%p[f]).reduce((v,f,E)=>v+f*b[E],0),k=h[m],y=h[m+1];if(!(k===Jt&&y===Jt))return i(l,{offset:Number(k),length:Number(y)})}}class G{constructor(t,n="/"){g(this,"store");g(this,"path");this.store=t,this.path=n}resolve(t){let n=new URL(`file://${this.path.endsWith("/")?this.path:`${this.path}/`}`);return new G(this.store,decodeURIComponent(new URL(t,n).pathname))}}var q;class Ct extends G{constructor(n,r,i){super(n,r);g(this,"kind","group");x(this,q);w(this,q,i)}get attrs(){return _(this,q).attributes}}q=new WeakMap;function Vt(e){var n;const t=e.find(r=>r.name==="transpose");return((n=t==null?void 0:t.configuration)==null?void 0:n.order)??"C"}const B=Symbol("zarrita.context");function je(e){return e[B]}function ze(e,t){let{configuration:n}=t.codecs.find(xe)??{},r={encode_chunk_key:be(t.chunk_key_encoding),TypedArray:ne(t.data_type),fill_value:t.fill_value};if(n){let s=Vt(n.codecs);return{...r,kind:"sharded",chunk_shape:n.chunk_shape,codec:kt({data_type:t.data_type,shape:n.chunk_shape,codecs:n.codecs}),get_strides(o){return U(o,s)},get_chunk_bytes:Ue(e,t.chunk_grid.configuration.chunk_shape,r.encode_chunk_key,n)}}let i=Vt(t.codecs);return{...r,kind:"regular",chunk_shape:t.chunk_grid.configuration.chunk_shape,codec:kt({data_type:t.data_type,shape:t.chunk_grid.configuration.chunk_shape,codecs:t.codecs}),get_strides(s){return U(s,i)},async get_chunk_bytes(s,o){let a=r.encode_chunk_key(s),c=e.resolve(a).path;return e.store.get(c,o)}}}var Kt,Qt,O,qt;let ot=(qt=class extends(Qt=G,Kt=B,Qt){constructor(n,r,i){super(n,r);g(this,"kind","array");x(this,O);g(this,Kt);w(this,O,{...i,fill_value:re(i)}),this[B]=ze(this,i)}get attrs(){return _(this,O).attributes}get shape(){return _(this,O).shape}get chunks(){return this[B].chunk_shape}get dtype(){return _(this,O).data_type}async getChunk(n,r){let i=this[B],s=await i.get_chunk_bytes(n,r);if(!s){let o=i.chunk_shape.reduce((c,u)=>c*u,1),a=new i.TypedArray(o);return a.fill(i.fill_value),{data:a,shape:i.chunk_shape,stride:i.get_strides(i.chunk_shape)}}return i.codec.decode(s)}is(n){return ve(this.dtype,n)}},O=new WeakMap,qt);function*$e(e,t,n=1){t===void 0&&(t=e,e=0);for(let r=e;r<t;r+=n)yield r}function*Ge(...e){if(e.length===0)return;const t=e.map(r=>r[Symbol.iterator]()),n=t.map(r=>r.next());if(n.some(r=>r.done))throw new Error("Input contains an empty iterator.");for(let r=0;;){if(n[r].done){if(t[r]=e[r][Symbol.iterator](),n[r]=t[r].next(),++r>=t.length)return}else yield n.map(({value:i})=>i),r=0;n[r]=t[r].next()}}function Be({start:e,stop:t,step:n},r){if(n===0)throw new Error("slice step cannot be zero");n=n??1;const i=n<0,[s,o]=i?[-1,r-1]:[0,r];return e===null?e=i?o:s:e<0?(e+=r,e<s&&(e=s)):e>o&&(e=o),t===null?t=i?s:o:t<0?(t+=r,t<s&&(t=s)):t>o&&(t=o),[e,t,n]}function at(e,t,n=null){return t===void 0&&(t=e,e=null),{start:e,stop:t,step:n}}function Pe(){const e=[];return{add:t=>e.push(t()),onIdle:()=>Promise.all(e)}}class Lt extends Error{constructor(t){super(t),this.name="IndexError"}}function Fe(e,t){throw new Lt(`too many indicies for array; expected ${t.length}, got ${e.length}`)}function De(e){throw new Lt(`index out of bounds for dimension with length ${e}`)}function Ye(){throw new Lt("only slices with step >= 1 are supported")}function We(e,t){e.length>t.length&&Fe(e,t)}function Je(e,t){return e=Math.trunc(e),e<0&&(e=t+e),(e>=t||e<0)&&De(t),e}class Ve{constructor({dim_sel:t,dim_len:n,dim_chunk_len:r}){g(this,"dim_sel");g(this,"dim_len");g(this,"dim_chunk_len");g(this,"nitems");t=Je(t,n),this.dim_sel=t,this.dim_len=n,this.dim_chunk_len=r,this.nitems=1}*[Symbol.iterator](){const t=Math.floor(this.dim_sel/this.dim_chunk_len),n=t*this.dim_chunk_len,r=this.dim_sel-n;yield{dim_chunk_ix:t,dim_chunk_sel:r}}}class Xt{constructor({dim_sel:t,dim_len:n,dim_chunk_len:r}){g(this,"start");g(this,"stop");g(this,"step");g(this,"dim_len");g(this,"dim_chunk_len");g(this,"nitems");g(this,"nchunks");const[i,s,o]=Be(t,n);this.start=i,this.stop=s,this.step=o,this.step<1&&Ye(),this.dim_len=n,this.dim_chunk_len=r,this.nitems=Math.max(0,Math.ceil((this.stop-this.start)/this.step)),this.nchunks=Math.ceil(this.dim_len/this.dim_chunk_len)}*[Symbol.iterator](){const t=Math.floor(this.start/this.dim_chunk_len),n=Math.ceil(this.stop/this.dim_chunk_len);for(const r of $e(t,n)){const i=r*this.dim_chunk_len,s=Math.min(this.dim_len,(r+1)*this.dim_chunk_len),o=s-i;let a=0,c=0;if(this.start<i){const p=(i-this.start)%this.step;p&&(c+=this.step-p),a=Math.ceil((i-this.start)/this.step)}else c=this.start-i;const u=this.stop>s?o:this.stop-i,l=[c,u,this.step],d=Math.ceil((u-c)/this.step),h=[a,a+d,1];yield{dim_chunk_ix:r,dim_chunk_sel:l,dim_out_sel:h}}}}function Xe(e,t){let n=[];return e===null?n=t.map(r=>at(null)):Array.isArray(e)&&(n=e.map(r=>r??at(null))),We(n,t),n}class He{constructor({selection:t,shape:n,chunk_shape:r}){g(this,"dim_indexers");g(this,"shape");this.dim_indexers=Xe(t,n).map((i,s)=>new(typeof i=="number"?Ve:Xt)({dim_sel:i,dim_len:n[s],dim_chunk_len:r[s]})),this.shape=this.dim_indexers.filter(i=>i instanceof Xt).map(i=>i.nitems)}*[Symbol.iterator](){for(const t of Ge(...this.dim_indexers)){const n=t.map(i=>i.dim_chunk_ix),r=t.map(i=>"dim_out_sel"in i?{from:i.dim_chunk_sel,to:i.dim_out_sel}:{from:i.dim_chunk_sel,to:null});yield{chunk_coords:n,mapping:r}}}}function Ze(e,t){return"get"in e?e.get(t):e[t]}async function Ke(e,t,n,r){var c;let i=je(e),s=new He({selection:t,shape:e.shape,chunk_shape:e.chunks}),o=r.prepare(new i.TypedArray(s.shape.reduce((u,l)=>u*l,1)),s.shape,i.get_strides(s.shape)),a=((c=n.create_queue)==null?void 0:c.call(n))??Pe();for(const{chunk_coords:u,mapping:l}of s)a.add(async()=>{let{data:d,shape:h,stride:p}=await e.getChunk(u,n.opts),b=r.prepare(d,h,p);r.set_from_chunk(o,b,l)});return await a.onIdle(),s.shape.length===0?Ze(o.data,0):o}function Mt(e,t=0,n){let r=n??e.length-t;return{length:r,subarray(i,s=r){return Mt(e,t+i,s-i)},set(i,s=0){for(let o=0;o<i.length;o++)e[t+s+o]=i.get(o)},get(i){return e[t+i]}}}function pt(e){return globalThis.Array.isArray(e.data)?{data:Mt(e.data),stride:e.stride,bytes_per_element:1}:{data:new Uint8Array(e.data.buffer,e.data.byteOffset,e.data.byteLength),stride:e.stride,bytes_per_element:e.data.BYTES_PER_ELEMENT}}function Qe(e){return"chars"in e?e.constructor.bind(null,e.chars):e.constructor}function qe(e,t){if(globalThis.Array.isArray(e.data))return Mt([t]);let n=Qe(e.data),r=new n([t]);return new Uint8Array(r.buffer,r.byteOffset,r.byteLength)}const tn={prepare(e,t,n){return{data:e,shape:t,stride:n}},set_scalar(e,t,n){let r=pt(e);Et(r,t,qe(e,n),r.bytes_per_element)},set_from_chunk(e,t,n){let r=pt(e);it(r,pt(t),r.bytes_per_element,n)}};async function en(e,t=null,n={}){return Ke(e,t,n,tn)}function oe(e,t,n){return n<0&&t<e?Math.floor((e-t-1)/-n)+1:e<t?Math.floor((t-e-1)/n)+1:0}function Et(e,t,n,r){if(t.length===0){e.data.set(n,0);return}const[i,...s]=t,[o,...a]=e.stride;if(typeof i=="number"){const h=e.data.subarray(o*i*r);Et({data:h,stride:a},s,n,r);return}const[c,u,l]=i,d=oe(c,u,l);if(s.length===0){for(let h=0;h<d;h++)e.data.set(n,o*(c+l*h)*r);return}for(let h=0;h<d;h++){const p=e.data.subarray(o*(c+l*h)*r);Et({data:p,stride:a},s,n,r)}}function it(e,t,n,r){const[i,...s]=r,[o,...a]=e.stride,[c,...u]=t.stride;if(i.from===null){if(s.length===0){e.data.set(t.data.subarray(0,n),i.to*n);return}it({data:e.data.subarray(o*i.to*n),stride:a},t,n,s);return}if(i.to===null){if(s.length===0){let y=i.from*n;e.data.set(t.data.subarray(y,y+n),0);return}it(e,{data:t.data.subarray(c*i.from*n),stride:u},n,s);return}const[l,d,h]=i.to,[p,b,m]=i.from,k=oe(l,d,h);if(s.length===0){if(h===1&&m===1&&o===1&&c===1){let y=p*n,v=k*n;e.data.set(t.data.subarray(y,y+v),l*n);return}for(let y=0;y<k;y++){let v=c*(p+m*y)*n;e.data.set(t.data.subarray(v,v+n),o*(l+h*y)*n)}return}for(let y=0;y<k;y++)it({data:e.data.subarray(o*(l+y*h)*n),stride:a},{data:t.data.subarray(c*(p+y*m)*n),stride:u},n,s)}let ct=nn();function nn(){let e=new WeakMap;function t(n){let r=e.get(n)??{v2:0,v3:0};return e.set(n,r),r}return{increment(n,r){t(n)[r]+=1},version_max(n){let r=t(n);return r.v3>r.v2?"v3":"v2"}}}async function rn(e){let t=await e.store.get(e.resolve(".zattrs").path);return t?tt(t):{}}async function sn(e,t={}){let n="store"in e?e:new G(e),r={};return(t.attrs??!0)&&(r=await rn(n)),t.kind==="array"?Ht(n,r):t.kind==="group"?Zt(n,r):Ht(n,r).catch(i=>(ie(i,et),Zt(n,r)))}async function Ht(e,t){let{path:n}=e.resolve(".zarray"),r=await e.store.get(n);if(!r)throw new et("v2 array",{cause:new Nt(n)});return ct.increment(e.store,"v2"),new ot(e.store,e.path,ke(tt(r),t))}async function Zt(e,t){let{path:n}=e.resolve(".zgroup"),r=await e.store.get(n);if(!r)throw new et("v2 group",{cause:new Nt(n)});return ct.increment(e.store,"v2"),new Ct(e.store,e.path,Ee(tt(r),t))}async function on(e){let{store:t,path:n}=e.resolve("zarr.json"),r=await e.store.get(n);if(!r)throw new et("v3 array or group",{cause:new Nt(n)});let i=tt(r);return i.node_type==="array"&&(i.fill_value=re(i)),i.node_type==="array"?new ot(t,e.path,i):new Ct(t,e.path,i)}async function an(e,t={}){let n="store"in e?e:new G(e),r=await on(n);if(ct.increment(n.store,"v3"),t.kind===void 0||t.kind==="array"&&r instanceof ot||t.kind==="group"&&r instanceof Ct)return r;let i=r instanceof ot?"array":"group";throw new Error(`Expected node of kind ${t.kind}, found ${i}.`)}async function M(e,t={}){let n="store"in e?e.store:e,r=ct.version_max(n),i=r==="v2"?M.v2:M.v3,s=r==="v2"?M.v3:M.v2;return i(e,t).catch(o=>(ie(o,et),s(e,t)))}M.v2=sn;M.v3=an;function cn(e,t,n,r){let i=e.projection;if(!i&&(typeof t.crs=="string"?i=yt(t.crs):"uri"in t.crs&&(i=yt(t.crs.uri)),!i))throw new Error(`Unsupported CRS: ${JSON.stringify(t.crs)}`);const s=t.orderedAxes,a=!(s?s.slice(0,2).map(f=>f.replace(/E|X|Lon/i,"e").replace(/N|Y|Lat/i,"n")).join(""):i.getAxisOrientation()).startsWith("en"),c=t.tileMatrices.sort(function(f,E){return E.cellSize-f.cellSize}),u={};for(let f=0;f<c.length;++f){const E=c[f];u[E.id]=E}const l={},d=[];if(r)for(let f=0;f<r.length;++f){const E=r[f],A=E.tileMatrix,C=u[A],N=c.indexOf(C);d[N]=A,l[A]=E}else for(let f=0;f<c.length;++f){const E=c[f].id;d.push(E)}const h=d.length,p=new Array(h),b=new Array(h),m=new Array(h),k=new Array(h),y=[-1/0,-1/0,1/0,1/0];for(let f=0;f<h;++f){const E=d[f],A=u[E],C=A.pointOfOrigin;a?p[f]=[C[1],C[0]]:p[f]=C,b[f]=A.cellSize,m[f]=[A.matrixWidth,A.matrixHeight],k[f]=[A.tileWidth,A.tileHeight];const N=l[E];if(N){const L=A.cellSize*A.tileWidth,lt=p[f][0]+N.minTileCol*L,nt=p[f][0]+(N.maxTileCol+1)*L,rt=A.cellSize*A.tileHeight,ae=A.cornerOfOrigin==="bottomLeft";let ut,dt;ae?(ut=p[f][1]+N.minTileRow*rt,dt=p[f][1]+(N.maxTileRow+1)*rt):(ut=p[f][1]-(N.maxTileRow+1)*rt,dt=p[f][1]-N.minTileRow*rt),ue(y,[lt,ut,nt,dt],y)}}return{grid:new vt({origins:p,resolutions:b,sizes:m,tileSizes:k,extent:r?y:void 0,matrixIds:d}),projection:i}}const ln=["d35379db-88df-4056-af3a-620245f8e347","f17cb550-5864-4468-aeb7-f3180cfb622f","689b58e2-cf7b-45e0-9fff-9cfc0883d6b4"];class mn extends pe{constructor(t){super({state:"loading",tileGrid:null,projection:t.projection||null,transition:t.transition,wrapX:t.wrapX}),this.url_=t.url,this.group_=t.group,this.error_=null,this.root_=null,this.consolidatedMetadata_=null,this.bands_=t.bands,this.bandsByLevel_=null,this.fillValue_,this.resampleMethod_=t.resample||"linear",this.bandCount=this.bands_.length,this.setLoader(this.loadTile_.bind(this)),this.tileGrid,this.configure_().then(()=>{this.setState("ready")}).catch(n=>{this.error_=n,this.setState("error")})}async configure_(){const t=new me(this.url_);this.root_=await M(t,{kind:"group"});try{this.consolidatedMetadata_=JSON.parse(new TextDecoder().decode(await t.get(this.root_.resolve("zarr.json").path))).consolidated_metadata.metadata}catch{}const r=(await M(this.root_.resolve(this.group_),{kind:"group"})).attrs;if("zarr_conventions"in r&&Array.isArray(r.zarr_conventions)&&ln.every(s=>r.zarr_conventions.find(o=>o.uuid===s))&&"layout"in r.multiscales){const{tileGrid:s,projection:o,bandsByLevel:a,fillValue:c}=un(r,this.consolidatedMetadata_,this.group_,this.bands_);this.bandsByLevel_=a,this.tileGrid=s,this.projection=o,this.fillValue_=c}else if("tile_matrix_set"in r.multiscales){const{tileGrid:s,projection:o}=dn(r);this.tileGrid=s,this.projection=o}const i=this.tileGrid.getExtent();setTimeout(()=>{this.viewResolver({showFullExtent:!0,projection:this.projection,resolutions:this.tileGrid.getResolutions(),center:he(fe(i),this.projection),extent:de(i,this.projection),zoom:1})})}async loadTile_(t,n,r,i){const s=this.tileGrid.getResolutions(),o=this.tileGrid.getResolution(t),a=this.tileGrid.getTileCoordExtent([t,n,r]),c=[],u=[];for(const p of this.bands_){let b,m,k=0;if(!this.bandsByLevel_)b=this.tileGrid.getMatrixId(t),m=o,k=t;else for(let L=0;L<s.length;L+=1){const lt=s[L];if(b&&lt<o)break;const nt=this.tileGrid.getMatrixId(L);this.bandsByLevel_[nt].includes(p)&&(b=nt,m=this.tileGrid.getResolution(L),k=L)}if(!b||!m)throw new Error(`Could not find available resolution for band ${p}`);const y=this.tileGrid.getOrigin(k),v=Math.round((a[0]-y[0])/m),f=Math.round((a[2]-y[0])/m),E=Math.round((y[1]-a[3])/m),A=Math.round((y[1]-a[1])/m),C=`${this.group_}/${b}/${p}`,N=await M(this.root_.resolve(C),{kind:"array"});c.push(en(N,[at(E,A),at(v,f)])),u.push(m)}const l=await Promise.all(c),[d,h]=_e(this.tileGrid.getTileSize(t));return hn(l,u,d,h,o,this.resampleMethod_,this.fillValue_||0)}}function un(e,t,n,r){const i=e.multiscales,s=e["spatial:bbox"],o=yt(e["proj:code"]),a=[],c=t?{}:null;let u;for(const d of i.layout){const h=d["spatial:transform"],p=h[0],b=[h[2],h[5]],m=d.asset;if(a.push({matrixId:m,resolution:p,origin:b}),t){const k=[];for(const y of r){const v=t[`${n}/${m}/${y}`];v&&(k.push(y),u===void 0&&(u=v.fill_value))}c[m]=k}}return a.sort((d,h)=>h.resolution-d.resolution),{tileGrid:new vt({extent:s,origins:a.map(d=>d.origin),resolutions:a.map(d=>d.resolution),matrixIds:a.map(d=>d.matrixId)}),projection:o,bandsByLevel:c,fillValue:u}}function dn(e){const t=e.multiscales,n=t.tile_matrix_set,r=t.tile_matrix_limits,i=n.tileMatrices.length,s=new Array(i);let o=!1;for(let u=0;u<i;u+=1){const l=n.tileMatrices[u],d=l.id;(l.tileWidth>512||l.tileHeight>512)&&(o=!0),s[u]=r[d]}const a=cn({},n,void 0,s);let c=a.grid;return o&&(c=new vt({tileSize:512,extent:c.getExtent(),origins:c.getOrigins(),resolutions:c.getResolutions(),matrixIds:c.getMatrixIds()})),{tileGrid:c,projection:a.projection}}function hn(e,t,n,r,i,s,o){const a=e.length,c=new Float32Array(n*r*a);for(let u=0;u<r;u++)for(let l=0;l<n;l++)for(let d=0;d<a;++d){const h=e[d],p=h.shape[0],b=h.shape[1],m=i/t[d];let k=o;if(m===1)u<p&&l<b&&(k=h.data[u*b+l]);else{const y=u*m,v=l*m;switch(s){case"nearest":{const f=Math.round(y),E=Math.round(v);f<p&&E<b&&(k=h.data[f*b+E]);break}default:throw new Error(`Unsupported resample method: ${s}`)}}isNaN(k)&&(k=o),c[a*(u*n+l)+d]=k}return c}export{mn as G};
