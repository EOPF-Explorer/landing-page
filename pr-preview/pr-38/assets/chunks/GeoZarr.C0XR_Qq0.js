import{e as O,f as L,h as S,i as $,j as N,k as B}from"./XYZ.zMTP1uvH.js";import{a as k,D}from"./DataTile.2Hs0Wrd9.js";import{F,o as A,g as W,s as z}from"./open.REf-oxTC.js";function U(w,i,p,s){let h=w.projection;if(!h&&(typeof i.crs=="string"?h=O(i.crs):"uri"in i.crs&&(h=O(i.crs.uri)),!h))throw new Error(`Unsupported CRS: ${JSON.stringify(i.crs)}`);const a=i.orderedAxes,r=!(a?a.slice(0,2).map(t=>t.replace(/E|X|Lon/i,"e").replace(/N|Y|Lat/i,"n")).join(""):h.getAxisOrientation()).startsWith("en"),o=i.tileMatrices.sort(function(t,f){return f.cellSize-t.cellSize}),n={};for(let t=0;t<o.length;++t){const f=o[t];n[f.id]=f}const g={},e=[];if(s)for(let t=0;t<s.length;++t){const f=s[t],m=f.tileMatrix,v=n[m],y=o.indexOf(v);e[y]=m,g[m]=f}else for(let t=0;t<o.length;++t){const f=o[t].id;e.push(f)}const d=e.length,u=new Array(d),x=new Array(d),l=new Array(d),_=new Array(d),b=[-1/0,-1/0,1/0,1/0];for(let t=0;t<d;++t){const f=e[t],m=n[f],v=m.pointOfOrigin;r?u[t]=[v[1],v[0]]:u[t]=v,x[t]=m.cellSize,l[t]=[m.matrixWidth,m.matrixHeight],_[t]=[m.tileWidth,m.tileHeight];const y=g[f];if(y){const G=m.cellSize*m.tileWidth,T=u[t][0]+y.minTileCol*G,j=u[t][0]+(y.maxTileCol+1)*G,I=m.cellSize*m.tileHeight,E=m.cornerOfOrigin==="bottomLeft";let M,C;E?(M=u[t][1]+y.minTileRow*I,C=u[t][1]+(y.maxTileRow+1)*I):(M=u[t][1]-(y.maxTileRow+1)*I,C=u[t][1]-y.minTileRow*I),L(b,[T,M,j,C],b)}}return{grid:new k({origins:u,resolutions:x,sizes:l,tileSizes:_,extent:s?b:void 0,matrixIds:e}),projection:h}}const H=["d35379db-88df-4056-af3a-620245f8e347","f17cb550-5864-4468-aeb7-f3180cfb622f","689b58e2-cf7b-45e0-9fff-9cfc0883d6b4"];class Q extends D{constructor(i){super({state:"loading",tileGrid:null,projection:i.projection||null,transition:i.transition,wrapX:i.wrapX}),this.url_=i.url,this.group_=i.group,this.error_=null,this.root_=null,this.consolidatedMetadata_=null,this.bands_=i.bands,this.bandsByLevel_=null,this.fillValue_,this.resampleMethod_=i.resample||"linear",this.bandCount=this.bands_.length,this.setLoader(this.loadTile_.bind(this)),this.tileGrid,this.configure_().then(()=>{this.setState("ready")}).catch(p=>{this.error_=p,this.setState("error")})}async configure_(){const i=new F(this.url_);this.root_=await A(i,{kind:"group"});try{this.consolidatedMetadata_=JSON.parse(new TextDecoder().decode(await i.get(this.root_.resolve("zarr.json").path))).consolidated_metadata.metadata}catch{}const s=(await A(this.root_.resolve(this.group_),{kind:"group"})).attrs;if("zarr_conventions"in s&&Array.isArray(s.zarr_conventions)&&H.every(a=>s.zarr_conventions.find(c=>c.uuid===a))&&"layout"in s.multiscales){const{tileGrid:a,projection:c,bandsByLevel:r,fillValue:o}=V(s,this.consolidatedMetadata_,this.group_,this.bands_);this.bandsByLevel_=r,this.tileGrid=a,this.projection=c,this.fillValue_=o}else if("tile_matrix_set"in s.multiscales){const{tileGrid:a,projection:c}=X(s);this.tileGrid=a,this.projection=c}const h=this.tileGrid.getExtent();setTimeout(()=>{this.viewResolver({showFullExtent:!0,projection:this.projection,resolutions:this.tileGrid.getResolutions(),center:$(N(h),this.projection),extent:S(h,this.projection),zoom:1})})}async loadTile_(i,p,s,h){const a=this.tileGrid.getResolutions(),c=this.tileGrid.getResolution(i),r=this.tileGrid.getTileCoordExtent([i,p,s]),o=[],n=[];for(const u of this.bands_){let x,l,_=0;if(!this.bandsByLevel_)x=this.tileGrid.getMatrixId(i),l=c,_=i;else for(let G=0;G<a.length;G+=1){const T=a[G];if(x&&T<c)break;const j=this.tileGrid.getMatrixId(G);this.bandsByLevel_[j].includes(u)&&(x=j,l=this.tileGrid.getResolution(G),_=G)}if(!x||!l)throw new Error(`Could not find available resolution for band ${u}`);const b=this.tileGrid.getOrigin(_),R=Math.round((r[0]-b[0])/l),t=Math.round((r[2]-b[0])/l),f=Math.round((b[1]-r[3])/l),m=Math.round((b[1]-r[1])/l),v=`${this.group_}/${x}/${u}`,y=await A(this.root_.resolve(v),{kind:"array"});o.push(W(y,[z(f,m),z(R,t)])),n.push(l)}const g=await Promise.all(o),[e,d]=B(this.tileGrid.getTileSize(i));return Z(g,n,e,d,c,this.resampleMethod_,this.fillValue_||0)}}function V(w,i,p,s){const h=w.multiscales,a=w["spatial:bbox"],c=O(w["proj:code"]),r=[],o=i?{}:null;let n;for(const e of h.layout){const d=e["spatial:transform"],u=d[0],x=[d[2],d[5]],l=e.asset;if(r.push({matrixId:l,resolution:u,origin:x}),i){const _=[];for(const b of s){const R=i[`${p}/${l}/${b}`];R&&(_.push(b),n===void 0&&(n=R.fill_value))}o[l]=_}}return r.sort((e,d)=>d.resolution-e.resolution),{tileGrid:new k({extent:a,origins:r.map(e=>e.origin),resolutions:r.map(e=>e.resolution),matrixIds:r.map(e=>e.matrixId)}),projection:c,bandsByLevel:o,fillValue:n}}function X(w){const i=w.multiscales,p=i.tile_matrix_set,s=i.tile_matrix_limits,h=p.tileMatrices.length,a=new Array(h);let c=!1;for(let n=0;n<h;n+=1){const g=p.tileMatrices[n],e=g.id;(g.tileWidth>512||g.tileHeight>512)&&(c=!0),a[n]=s[e]}const r=U({},p,void 0,a);let o=r.grid;return c&&(o=new k({tileSize:512,extent:o.getExtent(),origins:o.getOrigins(),resolutions:o.getResolutions(),matrixIds:o.getMatrixIds()})),{tileGrid:o,projection:r.projection}}function Z(w,i,p,s,h,a,c){const r=w.length,o=new Float32Array(p*s*r);for(let n=0;n<s;n++)for(let g=0;g<p;g++)for(let e=0;e<r;++e){const d=w[e],u=d.shape[0],x=d.shape[1],l=h/i[e];let _=c;if(l===1)n<u&&g<x&&(_=d.data[n*x+g]);else{const b=n*l,R=g*l;switch(a){case"nearest":{const t=Math.round(b),f=Math.round(R);t<u&&f<x&&(_=d.data[t*x+f]);break}default:throw new Error(`Unsupported resample method: ${a}`)}}isNaN(_)&&(_=c),o[r*(n*p+g)+e]=_}return o}export{Q as G};
