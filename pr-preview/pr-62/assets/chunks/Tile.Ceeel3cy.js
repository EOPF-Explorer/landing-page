import{A as ye,T as Ce,B as ce,C as le,D as V,G as Re,s as ae,H as Se,I as F,J as _e,K as ve,N as me,O as he,Q as de,U as z,Y as we,Z as H,_ as J,x as Ee,$ as Ke,o as je,a0 as Le,a1 as Pe,a2 as Fe}from"./XYZ.DUxXAAi-.js";import{C as Ae}from"./Layer.DfLjSwUf.js";function W(C,e,t){if(!(t in C))return C[t]=new Set([e]),!0;const i=C[t],o=i.has(e);return o||i.add(e),!o}function De(C,e,t){const i=C[t];return i?i.delete(e):!1}function ue(C,e){const t=C.layerStatesArray[C.layerIndex];t.extent&&(e=J(e,H(t.extent,C.viewState.projection)));const i=t.layer.getRenderSource();if(!i.getWrapX()){const o=i.getTileGridForProjection(C.viewState.projection).getExtent();o&&(e=J(e,o))}return e}class Ie extends Ae{constructor(e,t){super(e),t=t||{},this.extentChanged=!0,this.renderComplete=!1,this.renderedExtent_=null,this.renderedPixelRatio,this.renderedProjection=null,this.renderedTiles=[],this.renderedSourceKey_,this.renderedSourceRevision_,this.tempExtent=ye(),this.tempTileRange_=new Ce(0,0,0,0),this.tempTileCoord_=ce(0,0,0);const i=t.cacheSize!==void 0?t.cacheSize:512;this.tileCache_=new le(i),this.sourceTileCache_=null,this.maxStaleKeys=i*.5}getTileCache(){return this.tileCache_}getSourceTileCache(){return this.sourceTileCache_||(this.sourceTileCache_=new le(512)),this.sourceTileCache_}getOrCreateTile(e,t,i,o){const a=this.tileCache_,r=this.getLayer().getSource(),c=V(r,r.getKey(),e,t,i);let s;if(a.containsKey(c))s=a.get(c);else{const n=o.viewState.projection,l=r.getProjection();if(s=r.getTile(e,t,i,o.pixelRatio,n,!l||Re(l,n)?void 0:this.getSourceTileCache()),!s)return null;a.set(c,s)}return s}getTile(e,t,i,o){const a=this.getOrCreateTile(e,t,i,o);return a||null}getData(e){const t=this.frameState;if(!t)return null;const i=this.getLayer(),o=ae(t.pixelToCoordinateTransform,e.slice()),a=i.getExtent();if(a&&!Se(a,o))return null;const u=t.viewState,r=i.getRenderSource(),c=r.getTileGridForProjection(u.projection),s=r.getTilePixelRatio(t.pixelRatio);for(let n=c.getZForResolution(u.resolution);n>=c.getMinZoom();--n){const l=c.getTileCoordForCoordAndZ(o,n),h=this.getTile(n,l[1],l[2],t);if(!h||h.getState()!==F.LOADED)continue;const g=c.getOrigin(n),p=_e(c.getTileSize(n)),w=c.getResolution(n);let d;if(h instanceof ve||h instanceof me)d=h.getImage();else if(h instanceof he){if(d=de(h.getData()),!d)continue}else continue;const _=Math.floor(s*((o[0]-g[0])/w-l[1]*p[0])),A=Math.floor(s*((g[1]-o[1])/w-l[2]*p[1])),S=Math.round(s*r.getGutterForProjection(u.projection));return this.getImageData(d,_+S,A+S)}return null}prepareFrame(e){var o;this.renderedProjection?e.viewState.projection!==this.renderedProjection&&(this.tileCache_.clear(),this.renderedProjection=e.viewState.projection):this.renderedProjection=e.viewState.projection;const t=this.getLayer().getSource();if(!t)return!1;const i=t.getRevision();return this.renderedSourceRevision_?this.renderedSourceRevision_!==i&&(this.renderedSourceRevision_=i,this.renderedSourceKey_===t.getKey()&&(this.tileCache_.clear(),(o=this.sourceTileCache_)==null||o.clear())):this.renderedSourceRevision_=i,!0}enqueueTilesForNextExtent(){return!0}enqueueTiles(e,t,i,o,a){const u=e.viewState,r=this.getLayer(),c=r.getRenderSource(),s=c.getTileGridForProjection(u.projection),n=z(c);n in e.wantedTiles||(e.wantedTiles[n]={});const l=e.wantedTiles[n],h=r.getMapInternal(),g=Math.max(i-a,s.getMinZoom(),s.getZForResolution(Math.min(r.getMaxResolution(),h?h.getView().getResolutionForZoom(Math.max(r.getMinZoom(),0)):s.getResolution(0)),c.zDirection)),p=u.rotation,w=p?we(u.center,u.resolution,p,e.size):void 0;for(let d=i;d>=g;--d){const _=s.getTileRangeForExtentAndZ(t,d,this.tempTileRange_),A=s.getResolution(d);for(let S=_.minX;S<=_.maxX;++S)for(let E=_.minY;E<=_.maxY;++E){if(p&&!s.tileCoordIntersectsViewport([d,S,E],w))continue;const K=this.getTile(d,S,E,e);if(!K||!W(o,K,d))continue;const x=K.getKey();if(l[x]=!0,K.getState()===F.IDLE&&!e.tileQueue.isKeyQueued(x)){const Z=ce(d,S,E,this.tempTileCoord_);e.tileQueue.enqueue([K,n,s.getTileCoordCenter(Z),A])}}}}findStaleTile_(e,t){const i=this.tileCache_,o=e[0],a=e[1],u=e[2],r=this.getStaleKeys();for(let c=0;c<r.length;++c){const s=V(this.getLayer().getSource(),r[c],o,a,u);if(i.containsKey(s)){const n=i.peek(s);if(n.getState()===F.LOADED)return n.endTransition(z(this)),W(t,n,o),!0}}return!1}findAltTiles_(e,t,i,o){const a=e.getTileRangeForTileCoordAndZ(t,i,this.tempTileRange_);if(!a)return!1;let u=!0;const r=this.tileCache_,c=this.getLayer().getRenderSource(),s=c.getKey();for(let n=a.minX;n<=a.maxX;++n)for(let l=a.minY;l<=a.maxY;++l){const h=V(c,s,i,n,l);let g=!1;if(r.containsKey(h)){const p=r.peek(h);p.getState()===F.LOADED&&(W(o,p,i),g=!0)}g||(u=!1)}return u}renderFrame(e,t){this.renderComplete=!0;const i=e.layerStatesArray[e.layerIndex],o=e.viewState,a=o.projection,u=o.resolution,r=o.center,c=e.pixelRatio,s=this.getLayer(),n=s.getSource(),l=n.getTileGridForProjection(a),h=l.getZForResolution(u,n.zDirection),g=l.getResolution(h),p=n.getKey();this.renderedSourceKey_?this.renderedSourceKey_!==p&&(this.prependStaleKey(this.renderedSourceKey_),this.renderedSourceKey_=p):this.renderedSourceKey_=p;let w=e.extent;const d=n.getTilePixelRatio(c);this.prepareContainer(e,t);const _=this.context.canvas.width,A=this.context.canvas.height,S=i.extent&&H(i.extent);S&&(w=J(w,H(i.extent)));const E=g*_/2/d,K=g*A/2/d,D=[r[0]-E,r[1]-K,r[0]+E,r[1]+K],x={};this.renderedTiles.length=0;const Z=s.getPreload();if(e.nextExtent&&this.enqueueTilesForNextExtent()){const f=l.getZForResolution(o.nextResolution,n.zDirection),y=ue(e,e.nextExtent);this.enqueueTiles(e,y,f,x,Z)}const $=ue(e,w);if(this.enqueueTiles(e,$,h,x,0),Z>0&&setTimeout(()=>{this.enqueueTiles(e,$,h-1,x,Z-1)},0),!(h in x))return this.container;const ee=z(this),ge=e.time;for(const f of x[h]){const y=f.getState();if(y===F.EMPTY)continue;const j=f.tileCoord;if(y===F.LOADED&&f.getAlpha(ee,ge)===1){f.endTransition(ee);continue}if(y!==F.ERROR&&(this.renderComplete=!1),this.findStaleTile_(j,x)){De(x,f,h),e.animate=!0;continue}if(this.findAltTiles_(l,j,h+1,x))continue;const M=l.getMinZoom();for(let m=h-1;m>=M&&!this.findAltTiles_(l,j,m,x);--m);}const G=g/u*c/d,T=this.getRenderContext(e);Ee(this.tempTransform,_/2,A/2,G,G,0,-_/2,-A/2),i.extent&&this.clipUnrotated(T,e,S),n.getInterpolate()||(T.imageSmoothingEnabled=!1),this.preRender(T,e);const k=Object.keys(x).map(Number);k.sort(Ke);let v;const B=[],te=[];for(let f=k.length-1;f>=0;--f){const y=k[f],j=n.getTilePixelSize(y,c,a),I=l.getResolution(y)/g,M=j[0]*I*G,m=j[1]*I*G,b=l.getTileCoordForCoordAndZ(je(D),y),ie=l.getTileCoordExtent(b),q=ae(this.tempTransform,[d*(ie[0]-D[0])/g,d*(D[3]-ie[3])/g]),Te=d*n.getGutterForProjection(a);for(const O of x[y]){if(O.getState()!==F.LOADED)continue;const ne=O.tileCoord,oe=b[1]-ne[1],pe=Math.round(q[0]-(oe-1)*M),se=b[2]-ne[2],xe=Math.round(q[1]-(se-1)*m),L=Math.round(q[0]-oe*M),P=Math.round(q[1]-se*m),U=pe-L,Y=xe-P,re=k.length===1;let N=!1;v=[L,P,L+U,P,L+U,P+Y,L,P+Y];for(let X=0,fe=B.length;X<fe;++X)if(!re&&y<te[X]){const R=B[X];Le([L,P,L+U,P+Y],[R[0],R[3],R[4],R[7]])&&(N||(T.save(),N=!0),T.beginPath(),T.moveTo(v[0],v[1]),T.lineTo(v[2],v[3]),T.lineTo(v[4],v[5]),T.lineTo(v[6],v[7]),T.moveTo(R[6],R[7]),T.lineTo(R[4],R[5]),T.lineTo(R[2],R[3]),T.lineTo(R[0],R[1]),T.clip())}B.push(v),te.push(y),this.drawTile(O,e,L,P,U,Y,Te,re),N&&T.restore(),this.renderedTiles.unshift(O),this.updateUsedTiles(e.usedTiles,n,O)}}if(this.renderedResolution=g,this.extentChanged=!this.renderedExtent_||!Pe(this.renderedExtent_,D),this.renderedExtent_=D,this.renderedPixelRatio=c,this.postRender(this.context,e),i.extent&&T.restore(),T.imageSmoothingEnabled=!0,this.renderComplete){const f=(y,j)=>{var m;const Q=z(n),I=j.wantedTiles[Q],M=I?Object.keys(I).length:0;this.updateCacheSize(M),this.tileCache_.expireCache(),(m=this.sourceTileCache_)==null||m.expireCache()};e.postRenderFunctions.push(f)}return this.container}updateCacheSize(e){this.tileCache_.highWaterMark=Math.max(this.tileCache_.highWaterMark,e*2)}drawTile(e,t,i,o,a,u,r,c){let s;if(e instanceof he){if(s=de(e.getData()),!s)throw new Error("Rendering array data is not yet supported")}else s=this.getTileImage(e);if(!s)return;const n=this.getRenderContext(t),l=z(this),h=t.layerStatesArray[t.layerIndex],g=h.opacity*(c?e.getAlpha(l,t.time):1),p=g!==n.globalAlpha;p&&(n.save(),n.globalAlpha=g),n.drawImage(s,r,r,s.width-2*r,s.height-2*r,i,o,a,u),p&&n.restore(),g!==h.opacity?t.animate=!0:c&&e.endTransition(l)}getImage(){const e=this.context;return e?e.canvas:null}getTileImage(e){return e.getImage()}updateUsedTiles(e,t,i){const o=z(t);o in e||(e[o]={}),e[o][i.getKey()]=!0}}class Ze extends Fe{constructor(e){super(e)}createRenderer(){return new Ie(this,{cacheSize:this.getCacheSize()})}}export{Ie as C,Ze as T};
