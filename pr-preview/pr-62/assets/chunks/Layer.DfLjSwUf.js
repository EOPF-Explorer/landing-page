var T=Object.defineProperty;var E=(l,t,e)=>t in l?T(l,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):l[t]=e;var x=(l,t,e)=>E(l,typeof t!="symbol"?t+"":t,e);import{f as g,L as P,h as p,i as w,j as R,k as M,l as D,m as I,W as L,n as y,o as N,p as k,q as b,r as z,s as c,u as B,v as O,x as v,y as q,z as A,R as F,E as f}from"./XYZ.DUxXAAi-.js";class W{constructor(){x(this,"pushMethodArgs_",(...t)=>(this.push_(t),this));this.instructions_=[],this.zIndex=0,this.offset_=0,this.context_=new Proxy(g(),{get:(t,e)=>{if(typeof g()[e]=="function")return this.push_(e),this.pushMethodArgs_},set:(t,e,n)=>(this.push_(e,n),!0)})}push_(...t){const e=this.instructions_,n=this.zIndex+this.offset_;e[n]||(e[n]=[]),e[n].push(...t)}pushFunction(t){this.push_(t)}getContext(){return this.context_}draw(t){this.instructions_.forEach(e=>{for(let n=0,o=e.length;n<o;++n){const i=e[n];if(typeof i=="function"){i(t);continue}const s=e[++n];if(typeof t[i]=="function")t[i](...s);else{if(typeof s=="function"){t[i]=s(t);continue}t[i]=s}}})}clear(){this.instructions_.length=0,this.zIndex=0,this.offset_=0}offset(){this.offset_=this.instructions_.length,this.zIndex=0}}const K=[];let d=null;function Z(){d=y(1,1,void 0,{willReadFrequently:!0})}class U extends P{constructor(t){super(t),this.container=null,this.renderedResolution,this.tempTransform=p(),this.pixelTransform=p(),this.inversePixelTransform=p(),this.context=null,this.deferredContext_=null,this.containerReused=!1,this.frameState=null}getImageData(t,e,n){d||Z(),d.clearRect(0,0,1,1);let o;try{d.drawImage(t,e,n,1,1,0,0,1,1),o=d.getImageData(0,0,1,1).data}catch{return d=null,null}return o}getBackground(t){let n=this.getLayer().getBackground();return typeof n=="function"&&(n=n(t.viewState.resolution)),n||void 0}useContainer(t,e,n){const o=this.getLayer().getClassName();let i,s;if(t&&t.className===o&&(!n||t&&t.style.backgroundColor&&w(R(t.style.backgroundColor),R(n)))){const r=t.firstElementChild;M(r)&&(s=r.getContext("2d"))}if(s&&D(s.canvas.style.transform,e)?(this.container=t,this.context=s,this.containerReused=!0):this.containerReused?(this.container=null,this.context=null,this.containerReused=!1):this.container&&(this.container.style.backgroundColor=null),!this.container){i=L?I():document.createElement("div"),i.className=o;let r=i.style;r.position="absolute",r.width="100%",r.height="100%",s=y();const a=s.canvas;i.appendChild(a),r=a.style,r.position="absolute",r.left="0",r.transformOrigin="top left",this.container=i,this.context=s}!this.containerReused&&n&&!this.container.style.backgroundColor&&(this.container.style.backgroundColor=n)}clipUnrotated(t,e,n){const o=N(n),i=k(n),s=b(n),r=z(n);c(e.coordinateToPixelTransform,o),c(e.coordinateToPixelTransform,i),c(e.coordinateToPixelTransform,s),c(e.coordinateToPixelTransform,r);const a=this.inversePixelTransform;c(a,o),c(a,i),c(a,s),c(a,r),t.save(),t.beginPath(),t.moveTo(Math.round(o[0]),Math.round(o[1])),t.lineTo(Math.round(i[0]),Math.round(i[1])),t.lineTo(Math.round(s[0]),Math.round(s[1])),t.lineTo(Math.round(r[0]),Math.round(r[1])),t.clip()}prepareContainer(t,e){const n=t.extent,o=t.viewState.resolution,i=t.viewState.rotation,s=t.pixelRatio,r=Math.round(B(n)/o*s),a=Math.round(O(n)/o*s);v(this.pixelTransform,t.size[0]/2,t.size[1]/2,1/s,1/s,i,-r/2,-a/2),q(this.inversePixelTransform,this.pixelTransform);const u=A(this.pixelTransform);if(this.useContainer(e,u,this.getBackground(t)),!this.containerReused){const h=this.context.canvas;h.width!=r||h.height!=a?(h.width=r,h.height=a):this.context.clearRect(0,0,r,a),u!==h.style.transform&&(h.style.transform=u)}}dispatchRenderEvent_(t,e,n){const o=this.getLayer();if(o.hasListener(t)){const i=new F(t,this.inversePixelTransform,n,e);o.dispatchEvent(i)}}preRender(t,e){this.frameState=e,!e.declutter&&this.dispatchRenderEvent_(f.PRERENDER,t,e)}postRender(t,e){e.declutter||this.dispatchRenderEvent_(f.POSTRENDER,t,e)}renderDeferredInternal(t){}getRenderContext(t){return t.declutter&&!this.deferredContext_&&(this.deferredContext_=new W),t.declutter?this.deferredContext_.getContext():this.context}renderDeferred(t){t.declutter&&(this.dispatchRenderEvent_(f.PRERENDER,this.context,t),t.declutter&&this.deferredContext_&&(this.deferredContext_.draw(this.context),this.deferredContext_.clear()),this.renderDeferredInternal(t),this.dispatchRenderEvent_(f.POSTRENDER,this.context,t))}getRenderTransform(t,e,n,o,i,s,r){const a=i/2,u=s/2,h=o/e,C=-h,_=-t[0]+r,m=-t[1];return v(this.tempTransform,a,u,h,C,-n,_,m)}disposeInternal(){delete this.frameState,super.disposeInternal()}}export{U as C,W as Z,K as c};
