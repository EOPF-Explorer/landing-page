import{C as ye,L as ce,D as le,e as ae,B as Ce}from"./Layer.Cn7yGaI1.js";import{a as Re,c as he,g as V,b as F,t as me,I as Se,R as _e}from"./XYZ.CeC_mTYy.js";import{a as de,g as z,c as ve,b as we}from"./Polygon.DHQbtAHt.js";import{h as Ee,i as Ke,j as je,k as Le,l as H,m as J,n as Pe,o as Fe,p as De}from"./proj.DZpM1HQc.js";function W(C,e,t){if(!(t in C))return C[t]=new Set([e]),!0;const i=C[t],o=i.has(e);return o||i.add(e),!o}function Ie(C,e,t){const i=C[t];return i?i.delete(e):!1}function ue(C,e){const t=C.layerStatesArray[C.layerIndex];t.extent&&(e=J(e,H(t.extent,C.viewState.projection)));const i=t.layer.getRenderSource();if(!i.getWrapX()){const o=i.getTileGridForProjection(C.viewState.projection).getExtent();o&&(e=J(e,o))}return e}class Me extends ye{constructor(e,t){super(e),t=t||{},this.extentChanged=!0,this.renderComplete=!1,this.renderedExtent_=null,this.renderedPixelRatio,this.renderedProjection=null,this.renderedTiles=[],this.renderedSourceKey_,this.renderedSourceRevision_,this.tempExtent=Ee(),this.tempTileRange_=new Re(0,0,0,0),this.tempTileCoord_=he(0,0,0);const i=t.cacheSize!==void 0?t.cacheSize:512;this.tileCache_=new ce(i),this.sourceTileCache_=null,this.maxStaleKeys=i*.5}getTileCache(){return this.tileCache_}getSourceTileCache(){return this.sourceTileCache_||(this.sourceTileCache_=new ce(512)),this.sourceTileCache_}getOrCreateTile(e,t,i,o){const a=this.tileCache_,r=this.getLayer().getSource(),c=V(r,r.getKey(),e,t,i);let s;if(a.containsKey(c))s=a.get(c);else{const n=o.viewState.projection,l=r.getProjection();if(s=r.getTile(e,t,i,o.pixelRatio,n,!l||Ke(l,n)?void 0:this.getSourceTileCache()),!s)return null;a.set(c,s)}return s}getTile(e,t,i,o){const a=this.getOrCreateTile(e,t,i,o);return a||null}getData(e){const t=this.frameState;if(!t)return null;const i=this.getLayer(),o=de(t.pixelToCoordinateTransform,e.slice()),a=i.getExtent();if(a&&!je(a,o))return null;const u=t.viewState,r=i.getRenderSource(),c=r.getTileGridForProjection(u.projection),s=r.getTilePixelRatio(t.pixelRatio);for(let n=c.getZForResolution(u.resolution);n>=c.getMinZoom();--n){const l=c.getTileCoordForCoordAndZ(o,n),h=this.getTile(n,l[1],l[2],t);if(!h||h.getState()!==F.LOADED)continue;const g=c.getOrigin(n),p=me(c.getTileSize(n)),w=c.getResolution(n);let d;if(h instanceof Se||h instanceof _e)d=h.getImage();else if(h instanceof le){if(d=ae(h.getData()),!d)continue}else continue;const S=Math.floor(s*((o[0]-g[0])/w-l[1]*p[0])),D=Math.floor(s*((g[1]-o[1])/w-l[2]*p[1])),m=Math.round(s*r.getGutterForProjection(u.projection));return this.getImageData(d,S+m,D+m)}return null}prepareFrame(e){var o;this.renderedProjection?e.viewState.projection!==this.renderedProjection&&(this.tileCache_.clear(),this.renderedProjection=e.viewState.projection):this.renderedProjection=e.viewState.projection;const t=this.getLayer().getSource();if(!t)return!1;const i=t.getRevision();return this.renderedSourceRevision_?this.renderedSourceRevision_!==i&&(this.renderedSourceRevision_=i,this.renderedSourceKey_===t.getKey()&&(this.tileCache_.clear(),(o=this.sourceTileCache_)==null||o.clear())):this.renderedSourceRevision_=i,!0}enqueueTilesForNextExtent(){return!0}enqueueTiles(e,t,i,o,a){const u=e.viewState,r=this.getLayer(),c=r.getRenderSource(),s=c.getTileGridForProjection(u.projection),n=z(c);n in e.wantedTiles||(e.wantedTiles[n]={});const l=e.wantedTiles[n],h=r.getMapInternal(),g=Math.max(i-a,s.getMinZoom(),s.getZForResolution(Math.min(r.getMaxResolution(),h?h.getView().getResolutionForZoom(Math.max(r.getMinZoom(),0)):s.getResolution(0)),c.zDirection)),p=u.rotation,w=p?Le(u.center,u.resolution,p,e.size):void 0;for(let d=i;d>=g;--d){const S=s.getTileRangeForExtentAndZ(t,d,this.tempTileRange_),D=s.getResolution(d);for(let m=S.minX;m<=S.maxX;++m)for(let E=S.minY;E<=S.maxY;++E){if(p&&!s.tileCoordIntersectsViewport([d,m,E],w))continue;const K=this.getTile(d,m,E,e);if(!K||!W(o,K,d))continue;const x=K.getKey();if(l[x]=!0,K.getState()===F.IDLE&&!e.tileQueue.isKeyQueued(x)){const Z=he(d,m,E,this.tempTileCoord_);e.tileQueue.enqueue([K,n,s.getTileCoordCenter(Z),D])}}}}findStaleTile_(e,t){const i=this.tileCache_,o=e[0],a=e[1],u=e[2],r=this.getStaleKeys();for(let c=0;c<r.length;++c){const s=V(this.getLayer().getSource(),r[c],o,a,u);if(i.containsKey(s)){const n=i.peek(s);if(n.getState()===F.LOADED)return n.endTransition(z(this)),W(t,n,o),!0}}return!1}findAltTiles_(e,t,i,o){const a=e.getTileRangeForTileCoordAndZ(t,i,this.tempTileRange_);if(!a)return!1;let u=!0;const r=this.tileCache_,c=this.getLayer().getRenderSource(),s=c.getKey();for(let n=a.minX;n<=a.maxX;++n)for(let l=a.minY;l<=a.maxY;++l){const h=V(c,s,i,n,l);let g=!1;if(r.containsKey(h)){const p=r.peek(h);p.getState()===F.LOADED&&(W(o,p,i),g=!0)}g||(u=!1)}return u}renderFrame(e,t){this.renderComplete=!0;const i=e.layerStatesArray[e.layerIndex],o=e.viewState,a=o.projection,u=o.resolution,r=o.center,c=e.pixelRatio,s=this.getLayer(),n=s.getSource(),l=n.getTileGridForProjection(a),h=l.getZForResolution(u,n.zDirection),g=l.getResolution(h),p=n.getKey();this.renderedSourceKey_?this.renderedSourceKey_!==p&&(this.prependStaleKey(this.renderedSourceKey_),this.renderedSourceKey_=p):this.renderedSourceKey_=p;let w=e.extent;const d=n.getTilePixelRatio(c);this.prepareContainer(e,t);const S=this.context.canvas.width,D=this.context.canvas.height,m=i.extent&&H(i.extent);m&&(w=J(w,H(i.extent)));const E=g*S/2/d,K=g*D/2/d,I=[r[0]-E,r[1]-K,r[0]+E,r[1]+K],x={};this.renderedTiles.length=0;const Z=s.getPreload();if(e.nextExtent&&this.enqueueTilesForNextExtent()){const f=l.getZForResolution(o.nextResolution,n.zDirection),y=ue(e,e.nextExtent);this.enqueueTiles(e,y,f,x,Z)}const $=ue(e,w);if(this.enqueueTiles(e,$,h,x,0),Z>0&&setTimeout(()=>{this.enqueueTiles(e,$,h-1,x,Z-1)},0),!(h in x))return this.container;const ee=z(this),ge=e.time;for(const f of x[h]){const y=f.getState();if(y===F.EMPTY)continue;const j=f.tileCoord;if(y===F.LOADED&&f.getAlpha(ee,ge)===1){f.endTransition(ee);continue}if(y!==F.ERROR&&(this.renderComplete=!1),this.findStaleTile_(j,x)){Ie(x,f,h),e.animate=!0;continue}if(this.findAltTiles_(l,j,h+1,x))continue;const A=l.getMinZoom();for(let v=h-1;v>=A&&!this.findAltTiles_(l,j,v,x);--v);}const b=g/u*c/d,T=this.getRenderContext(e);ve(this.tempTransform,S/2,D/2,b,b,0,-S/2,-D/2),i.extent&&this.clipUnrotated(T,e,m),n.getInterpolate()||(T.imageSmoothingEnabled=!1),this.preRender(T,e);const k=Object.keys(x).map(Number);k.sort(we);let _;const B=[],te=[];for(let f=k.length-1;f>=0;--f){const y=k[f],j=n.getTilePixelSize(y,c,a),M=l.getResolution(y)/g,A=j[0]*M*b,v=j[1]*M*b,G=l.getTileCoordForCoordAndZ(Pe(I),y),ie=l.getTileCoordExtent(G),q=de(this.tempTransform,[d*(ie[0]-I[0])/g,d*(I[3]-ie[3])/g]),Te=d*n.getGutterForProjection(a);for(const O of x[y]){if(O.getState()!==F.LOADED)continue;const ne=O.tileCoord,oe=G[1]-ne[1],pe=Math.round(q[0]-(oe-1)*A),se=G[2]-ne[2],xe=Math.round(q[1]-(se-1)*v),L=Math.round(q[0]-oe*A),P=Math.round(q[1]-se*v),U=pe-L,X=xe-P,re=k.length===1;let N=!1;_=[L,P,L+U,P,L+U,P+X,L,P+X];for(let Y=0,fe=B.length;Y<fe;++Y)if(!re&&y<te[Y]){const R=B[Y];Fe([L,P,L+U,P+X],[R[0],R[3],R[4],R[7]])&&(N||(T.save(),N=!0),T.beginPath(),T.moveTo(_[0],_[1]),T.lineTo(_[2],_[3]),T.lineTo(_[4],_[5]),T.lineTo(_[6],_[7]),T.moveTo(R[6],R[7]),T.lineTo(R[4],R[5]),T.lineTo(R[2],R[3]),T.lineTo(R[0],R[1]),T.clip())}B.push(_),te.push(y),this.drawTile(O,e,L,P,U,X,Te,re),N&&T.restore(),this.renderedTiles.unshift(O),this.updateUsedTiles(e.usedTiles,n,O)}}if(this.renderedResolution=g,this.extentChanged=!this.renderedExtent_||!De(this.renderedExtent_,I),this.renderedExtent_=I,this.renderedPixelRatio=c,this.postRender(this.context,e),i.extent&&T.restore(),T.imageSmoothingEnabled=!0,this.renderComplete){const f=(y,j)=>{var v;const Q=z(n),M=j.wantedTiles[Q],A=M?Object.keys(M).length:0;this.updateCacheSize(A),this.tileCache_.expireCache(),(v=this.sourceTileCache_)==null||v.expireCache()};e.postRenderFunctions.push(f)}return this.container}updateCacheSize(e){this.tileCache_.highWaterMark=Math.max(this.tileCache_.highWaterMark,e*2)}drawTile(e,t,i,o,a,u,r,c){let s;if(e instanceof le){if(s=ae(e.getData()),!s)throw new Error("Rendering array data is not yet supported")}else s=this.getTileImage(e);if(!s)return;const n=this.getRenderContext(t),l=z(this),h=t.layerStatesArray[t.layerIndex],g=h.opacity*(c?e.getAlpha(l,t.time):1),p=g!==n.globalAlpha;p&&(n.save(),n.globalAlpha=g),n.drawImage(s,r,r,s.width-2*r,s.height-2*r,i,o,a,u),p&&n.restore(),g!==h.opacity?t.animate=!0:c&&e.endTransition(l)}getImage(){const e=this.context;return e?e.canvas:null}getTileImage(e){return e.getImage()}updateUsedTiles(e,t,i){const o=z(t);o in e||(e[o]={}),e[o][i.getKey()]=!0}}class be extends Ce{constructor(e){super(e)}createRenderer(){return new Me(this,{cacheSize:this.getCacheSize()})}}export{Me as C,be as T};
