const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/chunks/blosc.nNxqTOai.js","assets/chunks/chunk-INHXZS53.D3tQiqtZ.js","assets/chunks/lz4.COuoZ_ur.js","assets/chunks/zstd.CtzXwP91.js"])))=>i.map(i=>d[i]);
var te=Object.defineProperty;var Ot=e=>{throw TypeError(e)};var ee=(e,t,n)=>t in e?te(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var g=(e,t,n)=>ee(e,typeof t!="symbol"?t+"":t,n),St=(e,t,n)=>t.has(e)||Ot("Cannot "+n);var _=(e,t,n)=>(St(e,t,"read from private field"),n?n.call(e):t.get(e)),T=(e,t,n)=>t.has(e)?Ot("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,n),E=(e,t,n,r)=>(St(e,t,"write to private field"),r?r.call(e,n):t.set(e,n),n);import{aw as dt,_ as ne,ax as re,ay as ie,az as se,J as oe}from"./XYZ.DUxXAAi-.js";import{a as gt,D as ae,F as ce}from"./DataTile.DjcFEZpA.js";import{a5 as lt}from"./framework.C5l8s31R.js";var R;class Vt{constructor(t,n,r){T(this,R);typeof t=="number"?E(this,R,new Uint8Array(t)):t instanceof ArrayBuffer?E(this,R,new Uint8Array(t,n,r)):E(this,R,new Uint8Array(Array.from(t,i=>i?1:0)))}get BYTES_PER_ELEMENT(){return 1}get byteOffset(){return _(this,R).byteOffset}get byteLength(){return _(this,R).byteLength}get buffer(){return _(this,R).buffer}get length(){return _(this,R).length}get(t){let n=_(this,R)[t];return typeof n=="number"?n!==0:n}set(t,n){_(this,R)[t]=n?1:0}fill(t){_(this,R).fill(t?1:0)}*[Symbol.iterator](){for(let t=0;t<this.length;t++)yield this.get(t)}}R=new WeakMap;var z;class mt{constructor(t,n,r,i){g(this,"_data");g(this,"chars");T(this,z);if(this.chars=t,E(this,z,new TextEncoder),typeof n=="number")this._data=new Uint8Array(n*t);else if(n instanceof ArrayBuffer)i&&(i=i*t),this._data=new Uint8Array(n,r,i);else{let s=Array.from(n);this._data=new Uint8Array(s.length*t);for(let o=0;o<s.length;o++)this.set(o,s[o])}}get BYTES_PER_ELEMENT(){return this.chars}get byteOffset(){return this._data.byteOffset}get byteLength(){return this._data.byteLength}get buffer(){return this._data.buffer}get length(){return this.byteLength/this.BYTES_PER_ELEMENT}get(t){const n=new Uint8Array(this.buffer,this.byteOffset+this.chars*t,this.chars);return new TextDecoder().decode(n).replace(/\x00/g,"")}set(t,n){const r=new Uint8Array(this.buffer,this.byteOffset+this.chars*t,this.chars);r.fill(0),r.set(_(this,z).encode(n))}fill(t){const n=_(this,z).encode(t);for(let r=0;r<this.length;r++)this._data.set(n,r*this.chars)}*[Symbol.iterator](){for(let t=0;t<this.length;t++)yield this.get(t)}}z=new WeakMap;var I;const It=class It{constructor(t,n,r,i){T(this,I);g(this,"chars");if(this.chars=t,typeof n=="number")E(this,I,new Int32Array(n*t));else if(n instanceof ArrayBuffer)i&&(i*=t),E(this,I,new Int32Array(n,r,i));else{const s=n,o=new It(t,1);E(this,I,new Int32Array(function*(){for(let a of s)o.set(0,a),yield*_(o,I)}()))}}get BYTES_PER_ELEMENT(){return _(this,I).BYTES_PER_ELEMENT*this.chars}get byteLength(){return _(this,I).byteLength}get byteOffset(){return _(this,I).byteOffset}get buffer(){return _(this,I).buffer}get length(){return _(this,I).length/this.chars}get(t){const n=this.chars*t;let r="";for(let i=0;i<this.chars;i++)r+=String.fromCodePoint(_(this,I)[n+i]);return r.replace(/\u0000/g,"")}set(t,n){const r=this.chars*t,i=_(this,I).subarray(r,r+this.chars);i.fill(0);for(let s=0;s<this.chars;s++)i[s]=n.codePointAt(s)??0}fill(t){this.set(0,t);let n=_(this,I).subarray(0,this.chars);for(let r=1;r<this.length;r++)_(this,I).set(n,r*this.chars)}*[Symbol.iterator](){for(let t=0;t<this.length;t++)yield this.get(t)}};I=new WeakMap;let P=It;function K(e){const t=new TextDecoder().decode(e);return JSON.parse(t)}function jt(e,t){const n=t/2,r=t-1;let i=0;for(let s=0;s<e.length;s+=t)for(let o=0;o<n;o+=1)i=e[s+o],e[s+o]=e[s+r-o],e[s+r-o]=i}function Xt(e){if(e==="v2:object")return globalThis.Array;let t=e.match(/v2:([US])(\d+)/);if(t){let[,r,i]=t;return(r==="U"?P:mt).bind(null,Number(i))}let n={int8:Int8Array,int16:Int16Array,int32:Int32Array,int64:globalThis.BigInt64Array,uint8:Uint8Array,uint16:Uint16Array,uint32:Uint32Array,uint64:globalThis.BigUint64Array,float16:globalThis.Float16Array,float32:Float32Array,float64:Float64Array,bool:Vt}[e];return A(n,`Unknown or unsupported data_type: ${e}`),n}function L(e,t){const n=e.length;typeof t=="string"&&(t=t==="C"?Array.from({length:n},(s,o)=>o):Array.from({length:n},(s,o)=>n-1-o)),A(n===t.length,"Order length must match the number of dimensions.");let r=1,i=new Array(n);for(let s=t.length-1;s>=0;s--)i[t[s]]=r,r*=e[t[s]];return i}function le({name:e,configuration:t}){if(e==="default"){const n=(t==null?void 0:t.separator)??"/";return r=>["c",...r].join(n)}if(e==="v2"){const n=(t==null?void 0:t.separator)??".";return r=>r.join(n)||"0"}throw new Error(`Unknown chunk key encoding: ${e}`)}function ue(e){if(e==="|O")return{data_type:"v2:object"};let t=e.match(/^([<|>])(.*)$/);A(t,`Invalid dtype: ${e}`);let[,n,r]=t,i={b1:"bool",i1:"int8",u1:"uint8",i2:"int16",u2:"uint16",i4:"int32",u4:"uint32",i8:"int64",u8:"uint64",f2:"float16",f4:"float32",f8:"float64"}[r]??(r.startsWith("S")||r.startsWith("U")?`v2:${r}`:void 0);return A(i,`Unsupported or unknown dtype: ${e}`),n==="|"?{data_type:i}:{data_type:i,endian:n==="<"?"little":"big"}}function de(e,t={}){let n=[],r=ue(e.dtype);e.order==="F"&&n.push({name:"transpose",configuration:{order:"F"}}),"endian"in r&&r.endian==="big"&&n.push({name:"bytes",configuration:{endian:"big"}});for(let{id:i,...s}of e.filters??[])n.push({name:i,configuration:s});if(e.compressor){let{id:i,...s}=e.compressor;n.push({name:i,configuration:s})}return{zarr_format:3,node_type:"array",shape:e.shape,data_type:r.data_type,chunk_grid:{name:"regular",configuration:{chunk_shape:e.chunks}},chunk_key_encoding:{name:"v2",configuration:{separator:e.dimension_separator??"."}},codecs:n,fill_value:e.fill_value,attributes:t}}function he(e,t={}){return{zarr_format:3,node_type:"group",attributes:t}}function fe(e,t){if(t!=="number"&&t!=="bigint"&&t!=="boolean"&&t!=="object"&&t!=="string")return e===t;let n=e==="bool";if(t==="boolean")return n;let r=e.startsWith("v2:U")||e.startsWith("v2:S");if(t==="string")return r;let i=e==="int64"||e==="uint64";if(t==="bigint")return i;let s=e==="v2:object";return t==="object"?s:!r&&!i&&!n&&!s}function _e(e){return(e==null?void 0:e.name)==="sharding_indexed"}function Ht(e){return(e.data_type==="uint64"||e.data_type==="int64")&&e.fill_value!=null?BigInt(e.fill_value):e.fill_value}function Zt(e,...t){if(!t.some(n=>e instanceof n))throw e}function A(e,t=""){if(!e)throw new Error(t)}async function Kt(e,{format:t,signal:n}){const r=e instanceof Response?e:new Response(e);A(r.body,"Response does not contain body.");try{return await new Response(r.body.pipeThrough(new DecompressionStream(t),{signal:n})).arrayBuffer()}catch{throw n==null||n.throwIfAborted(),new Error(`Failed to decode ${t}`)}}class bt{constructor(t,n){g(this,"kind","array_to_array");A(t.keepbits>=0,"keepbits must be zero or positive")}static fromConfig(t,n){return new bt(t,n)}encode(t){throw new Error("`BitroundCodec.encode` is not implemented. Please open an issue at https://github.com/manzt/zarrita.js/issues.")}decode(t){return t}}const Lt=pe();function pe(){const e=new Uint32Array([305419896]);return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)[0]!==18}function zt(e){return"BYTES_PER_ELEMENT"in e?e.BYTES_PER_ELEMENT:4}var F,S,D,Y,U;const Rt=class Rt{constructor(t,n){g(this,"kind","array_to_bytes");T(this,F);T(this,S);T(this,D);T(this,Y);T(this,U);E(this,U,t==null?void 0:t.endian),E(this,S,Xt(n.data_type)),E(this,Y,n.shape),E(this,F,L(n.shape,"C"));const r=new(_(this,S))(0);E(this,D,r.BYTES_PER_ELEMENT)}static fromConfig(t,n){return new Rt(t,n)}encode(t){let n=new Uint8Array(t.data.buffer);return Lt&&_(this,U)==="big"&&jt(n,zt(_(this,S))),n}decode(t){return Lt&&_(this,U)==="big"&&jt(t,zt(_(this,S))),{data:new(_(this,S))(t.buffer,t.byteOffset,t.byteLength/_(this,D)),shape:_(this,Y),stride:_(this,F)}}};F=new WeakMap,S=new WeakMap,D=new WeakMap,Y=new WeakMap,U=new WeakMap;let nt=Rt;class wt{constructor(){g(this,"kind","bytes_to_bytes")}static fromConfig(){return new wt}encode(t){throw new Error("Not implemented")}decode(t){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength-4)}}class kt{constructor(){g(this,"kind","bytes_to_bytes")}static fromConfig(t){return new kt}encode(t){throw new Error("Gzip encoding is not enabled by default. Please register a custom codec with `numcodecs/gzip`.")}async decode(t){const n=await Kt(t,{format:"gzip"});return new Uint8Array(n)}}function ye(e,t){return A(!Number.isNaN(t),"JsonCodec allow_nan is false but NaN was encountered during encoding."),A(t!==Number.POSITIVE_INFINITY,"JsonCodec allow_nan is false but Infinity was encountered during encoding."),A(t!==Number.NEGATIVE_INFINITY,"JsonCodec allow_nan is false but -Infinity was encountered during encoding."),t}function ge(e,t){return t instanceof Object&&!Array.isArray(t)?Object.keys(t).sort().reduce((n,r)=>(n[r]=t[r],n),{}):t}var W,J;const Nt=class Nt{constructor(t={}){g(this,"configuration");g(this,"kind","array_to_bytes");T(this,W);T(this,J);this.configuration=t;const{encoding:n="utf-8",skipkeys:r=!1,ensure_ascii:i=!0,check_circular:s=!0,allow_nan:o=!0,sort_keys:a=!0,indent:c,strict:u=!0}=t;let l=t.separators;l||(c?l=[", ",": "]:l=[",",":"]),E(this,W,{encoding:n,skipkeys:r,ensure_ascii:i,check_circular:s,allow_nan:o,indent:c,separators:l,sort_keys:a}),E(this,J,{strict:u})}static fromConfig(t){return new Nt(t)}encode(t){const{indent:n,encoding:r,ensure_ascii:i,check_circular:s,allow_nan:o,sort_keys:a}=_(this,W);A(r==="utf-8","JsonCodec does not yet support non-utf-8 encoding.");const c=[];A(s,"JsonCodec does not yet support skipping the check for circular references during encoding."),o||c.push(ye),a&&c.push(ge);const u=Array.from(t.data);u.push("|O"),u.push(t.shape);let l;c.length&&(l=(h,p)=>{let b=p;for(let m of c)b=m(h,b);return b});let d=JSON.stringify(u,l,n);return i&&(d=d.replace(/[\u007F-\uFFFF]/g,h=>{const p=`0000${h.charCodeAt(0).toString(16)}`;return`\\u${p.substring(p.length-4)}`})),new TextEncoder().encode(d)}decode(t){const{strict:n}=_(this,J);A(n,"JsonCodec does not yet support non-strict decoding.");const r=K(t),i=r.pop();r.pop(),A(i,"0D not implemented for JsonCodec.");const s=L(i,"C");return{data:r,shape:i,stride:s}}};W=new WeakMap,J=new WeakMap;let ht=Nt;function Ut(e){return e instanceof Vt||e instanceof mt||e instanceof P?new Proxy(e,{get(n,r){return n.get(Number(r))},set(n,r,i){return n.set(Number(r),i),!0}}):e}function me(e,t){let n;return e.data instanceof mt||e.data instanceof P?n=new e.constructor(e.data.length,e.data.chars):n=new e.constructor(e.data.length),{data:n,shape:e.shape,stride:L(e.shape,t)}}function be(e,t){let n=me(e,t),r=e.shape.length,i=e.data.length,s=Array(r).fill(0),o=Ut(e.data),a=Ut(n.data);for(let c=0;c<i;c++){let u=0;for(let l=0;l<r;l++)u+=s[l]*n.stride[l];a[u]=o[c],s[0]+=1;for(let l=0;l<r;l++)if(s[l]===e.shape[l]){if(l+1===r)break;s[l]=0,s[l+1]+=1}}return n}function we(e){let t=e.shape.length;return A(t===e.stride.length,"Shape and stride must have the same length."),e.stride.map((n,r)=>({stride:n,index:r})).sort((n,r)=>r.stride-n.stride).map(n=>n.index)}function ke(e,t){let n=we(e);return A(n.length===t.length,"Orders must match"),n.every((r,i)=>r===t[i])}var V,$;const Ct=class Ct{constructor(t,n){g(this,"kind","array_to_array");T(this,V);T(this,$);let r=t.order??"C",i=n.shape.length,s=new Array(i),o=new Array(i);if(r==="C")for(let a=0;a<i;++a)s[a]=a,o[a]=a;else if(r==="F")for(let a=0;a<i;++a)s[a]=i-a-1,o[a]=i-a-1;else s=r,s.forEach((a,c)=>{A(o[a]===void 0,`Invalid permutation: ${JSON.stringify(r)}`),o[a]=c});E(this,V,s),E(this,$,o)}static fromConfig(t,n){return new Ct(t,n)}encode(t){return ke(t,_(this,$))?t:be(t,_(this,$))}decode(t){return{data:t.data,shape:t.shape,stride:L(t.shape,_(this,V))}}};V=new WeakMap,$=new WeakMap;let ft=Ct;var X,H;const Mt=class Mt{constructor(t){g(this,"kind","array_to_bytes");T(this,X);T(this,H);E(this,X,t),E(this,H,L(t,"C"))}static fromConfig(t,n){return new Mt(n.shape)}encode(t){throw new Error("Method not implemented.")}decode(t){let n=new TextDecoder,r=new DataView(t.buffer),i=Array(r.getUint32(0,!0)),s=4;for(let o=0;o<i.length;o++){let a=r.getUint32(s,!0);s+=4,i[o]=n.decode(t.buffer.slice(s,s+a)),s+=a}return{data:i,shape:_(this,X),stride:_(this,H)}}};X=new WeakMap,H=new WeakMap;let _t=Mt;class Et{constructor(){g(this,"kind","bytes_to_bytes")}static fromConfig(t){return new Et}encode(t){throw new Error("Zlib encoding is not enabled by default. Please register a codec with `numcodecs/zlib`.")}async decode(t){const n=await Kt(t,{format:"deflate"});return new Uint8Array(n)}}function Ee(){return new Map().set("blosc",()=>lt(()=>import("./blosc.nNxqTOai.js"),__vite__mapDeps([0,1])).then(e=>e.default)).set("lz4",()=>lt(()=>import("./lz4.COuoZ_ur.js"),__vite__mapDeps([2,1])).then(e=>e.default)).set("zstd",()=>lt(()=>import("./zstd.CtzXwP91.js"),__vite__mapDeps([3,1])).then(e=>e.default)).set("gzip",()=>kt).set("zlib",()=>Et).set("transpose",()=>ft).set("bytes",()=>nt).set("crc32c",()=>wt).set("vlen-utf8",()=>_t).set("json2",()=>ht).set("bitround",()=>bt)}const ve=Ee();function pt(e){let t;return{async encode(n){t||(t=await $t(e));for(const i of t.array_to_array)n=await i.encode(n);let r=await t.array_to_bytes.encode(n);for(const i of t.bytes_to_bytes)r=await i.encode(r);return r},async decode(n){t||(t=await $t(e));for(let i=t.bytes_to_bytes.length-1;i>=0;i--)n=await t.bytes_to_bytes[i].decode(n);let r=await t.array_to_bytes.decode(n);for(let i=t.array_to_array.length-1;i>=0;i--)r=await t.array_to_array[i].decode(r);return r}}}async function $t(e){let t=e.codecs.map(async s=>{var a;let o=await((a=ve.get(s.name))==null?void 0:a());return A(o,`Unknown codec: ${s.name}`),{Codec:o,meta:s}}),n=[],r,i=[];for await(let{Codec:s,meta:o}of t){let a=s.fromConfig(o.configuration,e);switch(a.kind){case"array_to_array":n.push(a);break;case"array_to_bytes":r=a;break;default:i.push(a)}}return r||(A(xe(e),`Cannot encode ${e.data_type} to bytes without a codec`),r=nt.fromConfig({endian:"little"},e)),{array_to_array:n,array_to_bytes:r,bytes_to_bytes:i}}function xe(e){return e.data_type!=="v2:object"}class Q extends Error{constructor(t,n={}){super(`Node not found: ${t}`,n),this.name="NodeNotFoundError"}}class vt extends Error{constructor(t){super(`Missing key: ${t}`),this.name="KeyError"}}const Gt=18446744073709551615n;function Ae(e,t,n,r){A(e.store.getRange,"Store does not support range requests");let i=e.store.getRange.bind(e.store),s=t.map((c,u)=>c/r.chunk_shape[u]),o=pt({data_type:"uint64",shape:[...s,2],codecs:r.index_codecs}),a={};return async c=>{let u=c.map((v,f)=>Math.floor(v/s[f])),l=e.resolve(n(u)).path,d;if(l in a)d=a[l];else{let v=4,f=16*s.reduce((x,C)=>x*C,1),k=await i(l,{suffixLength:f+v});d=a[l]=k?await o.decode(k):null}if(d===null)return;let{data:h,shape:p,stride:b}=d,m=c.map((v,f)=>v%p[f]).reduce((v,f,k)=>v+f*b[k],0),w=h[m],y=h[m+1];if(!(w===Gt&&y===Gt))return i(l,{offset:Number(w),length:Number(y)})}}class G{constructor(t,n="/"){g(this,"store");g(this,"path");this.store=t,this.path=n}resolve(t){let n=new URL(`file://${this.path.endsWith("/")?this.path:`${this.path}/`}`);return new G(this.store,decodeURIComponent(new URL(t,n).pathname))}}var Z;class xt extends G{constructor(n,r,i){super(n,r);g(this,"kind","group");T(this,Z);E(this,Z,i)}get attrs(){return _(this,Z).attributes}}Z=new WeakMap;function Bt(e){var n;const t=e.find(r=>r.name==="transpose");return((n=t==null?void 0:t.configuration)==null?void 0:n.order)??"C"}const B=Symbol("zarrita.context");function Te(e){return e[B]}function Ie(e,t){let{configuration:n}=t.codecs.find(_e)??{},r={encode_chunk_key:le(t.chunk_key_encoding),TypedArray:Xt(t.data_type),fill_value:t.fill_value};if(n){let s=Bt(n.codecs);return{...r,kind:"sharded",chunk_shape:n.chunk_shape,codec:pt({data_type:t.data_type,shape:n.chunk_shape,codecs:n.codecs}),get_strides(o){return L(o,s)},get_chunk_bytes:Ae(e,t.chunk_grid.configuration.chunk_shape,r.encode_chunk_key,n)}}let i=Bt(t.codecs);return{...r,kind:"regular",chunk_shape:t.chunk_grid.configuration.chunk_shape,codec:pt({data_type:t.data_type,shape:t.chunk_grid.configuration.chunk_shape,codecs:t.codecs}),get_strides(s){return L(s,i)},async get_chunk_bytes(s,o){let a=r.encode_chunk_key(s),c=e.resolve(a).path;return e.store.get(c,o)}}}var Yt,Wt,j,Jt;let rt=(Jt=class extends(Wt=G,Yt=B,Wt){constructor(n,r,i){super(n,r);g(this,"kind","array");T(this,j);g(this,Yt);E(this,j,{...i,fill_value:Ht(i)}),this[B]=Ie(this,i)}get attrs(){return _(this,j).attributes}get shape(){return _(this,j).shape}get chunks(){return this[B].chunk_shape}get dtype(){return _(this,j).data_type}async getChunk(n,r){let i=this[B],s=await i.get_chunk_bytes(n,r);if(!s){let o=i.chunk_shape.reduce((c,u)=>c*u,1),a=new i.TypedArray(o);return a.fill(i.fill_value),{data:a,shape:i.chunk_shape,stride:i.get_strides(i.chunk_shape)}}return i.codec.decode(s)}is(n){return fe(this.dtype,n)}},j=new WeakMap,Jt);function*Re(e,t,n=1){t===void 0&&(t=e,e=0);for(let r=e;r<t;r+=n)yield r}function*Ne(...e){if(e.length===0)return;const t=e.map(r=>r[Symbol.iterator]()),n=t.map(r=>r.next());if(n.some(r=>r.done))throw new Error("Input contains an empty iterator.");for(let r=0;;){if(n[r].done){if(t[r]=e[r][Symbol.iterator](),n[r]=t[r].next(),++r>=t.length)return}else yield n.map(({value:i})=>i),r=0;n[r]=t[r].next()}}function Ce({start:e,stop:t,step:n},r){if(n===0)throw new Error("slice step cannot be zero");n=n??1;const i=n<0,[s,o]=i?[-1,r-1]:[0,r];return e===null?e=i?o:s:e<0?(e+=r,e<s&&(e=s)):e>o&&(e=o),t===null?t=i?s:o:t<0?(t+=r,t<s&&(t=s)):t>o&&(t=o),[e,t,n]}function it(e,t,n=null){return t===void 0&&(t=e,e=null),{start:e,stop:t,step:n}}function Me(){const e=[];return{add:t=>e.push(t()),onIdle:()=>Promise.all(e)}}class At extends Error{constructor(t){super(t),this.name="IndexError"}}function Oe(e,t){throw new At(`too many indicies for array; expected ${t.length}, got ${e.length}`)}function Se(e){throw new At(`index out of bounds for dimension with length ${e}`)}function je(){throw new At("only slices with step >= 1 are supported")}function Le(e,t){e.length>t.length&&Oe(e,t)}function ze(e,t){return e=Math.trunc(e),e<0&&(e=t+e),(e>=t||e<0)&&Se(t),e}class Ue{constructor({dim_sel:t,dim_len:n,dim_chunk_len:r}){g(this,"dim_sel");g(this,"dim_len");g(this,"dim_chunk_len");g(this,"nitems");t=ze(t,n),this.dim_sel=t,this.dim_len=n,this.dim_chunk_len=r,this.nitems=1}*[Symbol.iterator](){const t=Math.floor(this.dim_sel/this.dim_chunk_len),n=t*this.dim_chunk_len,r=this.dim_sel-n;yield{dim_chunk_ix:t,dim_chunk_sel:r}}}class Pt{constructor({dim_sel:t,dim_len:n,dim_chunk_len:r}){g(this,"start");g(this,"stop");g(this,"step");g(this,"dim_len");g(this,"dim_chunk_len");g(this,"nitems");g(this,"nchunks");const[i,s,o]=Ce(t,n);this.start=i,this.stop=s,this.step=o,this.step<1&&je(),this.dim_len=n,this.dim_chunk_len=r,this.nitems=Math.max(0,Math.ceil((this.stop-this.start)/this.step)),this.nchunks=Math.ceil(this.dim_len/this.dim_chunk_len)}*[Symbol.iterator](){const t=Math.floor(this.start/this.dim_chunk_len),n=Math.ceil(this.stop/this.dim_chunk_len);for(const r of Re(t,n)){const i=r*this.dim_chunk_len,s=Math.min(this.dim_len,(r+1)*this.dim_chunk_len),o=s-i;let a=0,c=0;if(this.start<i){const p=(i-this.start)%this.step;p&&(c+=this.step-p),a=Math.ceil((i-this.start)/this.step)}else c=this.start-i;const u=this.stop>s?o:this.stop-i,l=[c,u,this.step],d=Math.ceil((u-c)/this.step),h=[a,a+d,1];yield{dim_chunk_ix:r,dim_chunk_sel:l,dim_out_sel:h}}}}function $e(e,t){let n=[];return e===null?n=t.map(r=>it(null)):Array.isArray(e)&&(n=e.map(r=>r??it(null))),Le(n,t),n}class Ge{constructor({selection:t,shape:n,chunk_shape:r}){g(this,"dim_indexers");g(this,"shape");this.dim_indexers=$e(t,n).map((i,s)=>new(typeof i=="number"?Ue:Pt)({dim_sel:i,dim_len:n[s],dim_chunk_len:r[s]})),this.shape=this.dim_indexers.filter(i=>i instanceof Pt).map(i=>i.nitems)}*[Symbol.iterator](){for(const t of Ne(...this.dim_indexers)){const n=t.map(i=>i.dim_chunk_ix),r=t.map(i=>"dim_out_sel"in i?{from:i.dim_chunk_sel,to:i.dim_out_sel}:{from:i.dim_chunk_sel,to:null});yield{chunk_coords:n,mapping:r}}}}function Be(e,t){return"get"in e?e.get(t):e[t]}async function Pe(e,t,n,r){var c;let i=Te(e),s=new Ge({selection:t,shape:e.shape,chunk_shape:e.chunks}),o=r.prepare(new i.TypedArray(s.shape.reduce((u,l)=>u*l,1)),s.shape,i.get_strides(s.shape)),a=((c=n.create_queue)==null?void 0:c.call(n))??Me();for(const{chunk_coords:u,mapping:l}of s)a.add(async()=>{let{data:d,shape:h,stride:p}=await e.getChunk(u,n.opts),b=r.prepare(d,h,p);r.set_from_chunk(o,b,l)});return await a.onIdle(),s.shape.length===0?Be(o.data,0):o}function Tt(e,t=0,n){let r=n??e.length-t;return{length:r,subarray(i,s=r){return Tt(e,t+i,s-i)},set(i,s=0){for(let o=0;o<i.length;o++)e[t+s+o]=i.get(o)},get(i){return e[t+i]}}}function ut(e){return globalThis.Array.isArray(e.data)?{data:Tt(e.data),stride:e.stride,bytes_per_element:1}:{data:new Uint8Array(e.data.buffer,e.data.byteOffset,e.data.byteLength),stride:e.stride,bytes_per_element:e.data.BYTES_PER_ELEMENT}}function Fe(e){return"chars"in e?e.constructor.bind(null,e.chars):e.constructor}function De(e,t){if(globalThis.Array.isArray(e.data))return Tt([t]);let n=Fe(e.data),r=new n([t]);return new Uint8Array(r.buffer,r.byteOffset,r.byteLength)}const Ye={prepare(e,t,n){return{data:e,shape:t,stride:n}},set_scalar(e,t,n){let r=ut(e);yt(r,t,De(e,n),r.bytes_per_element)},set_from_chunk(e,t,n){let r=ut(e);et(r,ut(t),r.bytes_per_element,n)}};async function We(e,t=null,n={}){return Pe(e,t,n,Ye)}function Qt(e,t,n){return n<0&&t<e?Math.floor((e-t-1)/-n)+1:e<t?Math.floor((t-e-1)/n)+1:0}function yt(e,t,n,r){if(t.length===0){e.data.set(n,0);return}const[i,...s]=t,[o,...a]=e.stride;if(typeof i=="number"){const h=e.data.subarray(o*i*r);yt({data:h,stride:a},s,n,r);return}const[c,u,l]=i,d=Qt(c,u,l);if(s.length===0){for(let h=0;h<d;h++)e.data.set(n,o*(c+l*h)*r);return}for(let h=0;h<d;h++){const p=e.data.subarray(o*(c+l*h)*r);yt({data:p,stride:a},s,n,r)}}function et(e,t,n,r){const[i,...s]=r,[o,...a]=e.stride,[c,...u]=t.stride;if(i.from===null){if(s.length===0){e.data.set(t.data.subarray(0,n),i.to*n);return}et({data:e.data.subarray(o*i.to*n),stride:a},t,n,s);return}if(i.to===null){if(s.length===0){let y=i.from*n;e.data.set(t.data.subarray(y,y+n),0);return}et(e,{data:t.data.subarray(c*i.from*n),stride:u},n,s);return}const[l,d,h]=i.to,[p,b,m]=i.from,w=Qt(l,d,h);if(s.length===0){if(h===1&&m===1&&o===1&&c===1){let y=p*n,v=w*n;e.data.set(t.data.subarray(y,y+v),l*n);return}for(let y=0;y<w;y++){let v=c*(p+m*y)*n;e.data.set(t.data.subarray(v,v+n),o*(l+h*y)*n)}return}for(let y=0;y<w;y++)et({data:e.data.subarray(o*(l+y*h)*n),stride:a},{data:t.data.subarray(c*(p+y*m)*n),stride:u},n,s)}let st=Je();function Je(){let e=new WeakMap;function t(n){let r=e.get(n)??{v2:0,v3:0};return e.set(n,r),r}return{increment(n,r){t(n)[r]+=1},version_max(n){let r=t(n);return r.v3>r.v2?"v3":"v2"}}}async function Ve(e){let t=await e.store.get(e.resolve(".zattrs").path);return t?K(t):{}}async function Xe(e,t={}){let n="store"in e?e:new G(e),r={};return(t.attrs??!0)&&(r=await Ve(n)),t.kind==="array"?Ft(n,r):t.kind==="group"?Dt(n,r):Ft(n,r).catch(i=>(Zt(i,Q),Dt(n,r)))}async function Ft(e,t){let{path:n}=e.resolve(".zarray"),r=await e.store.get(n);if(!r)throw new Q("v2 array",{cause:new vt(n)});return st.increment(e.store,"v2"),new rt(e.store,e.path,de(K(r),t))}async function Dt(e,t){let{path:n}=e.resolve(".zgroup"),r=await e.store.get(n);if(!r)throw new Q("v2 group",{cause:new vt(n)});return st.increment(e.store,"v2"),new xt(e.store,e.path,he(K(r),t))}async function He(e){let{store:t,path:n}=e.resolve("zarr.json"),r=await e.store.get(n);if(!r)throw new Q("v3 array or group",{cause:new vt(n)});let i=K(r);return i.node_type==="array"&&(i.fill_value=Ht(i)),i.node_type==="array"?new rt(t,e.path,i):new xt(t,e.path,i)}async function Ze(e,t={}){let n="store"in e?e:new G(e),r=await He(n);if(st.increment(n.store,"v3"),t.kind===void 0||t.kind==="array"&&r instanceof rt||t.kind==="group"&&r instanceof xt)return r;let i=r instanceof rt?"array":"group";throw new Error(`Expected node of kind ${t.kind}, found ${i}.`)}async function O(e,t={}){let n="store"in e?e.store:e,r=st.version_max(n),i=r==="v2"?O.v2:O.v3,s=r==="v2"?O.v3:O.v2;return i(e,t).catch(o=>(Zt(o,Q),s(e,t)))}O.v2=Xe;O.v3=Ze;function Ke(e,t,n,r){let i=e.projection;if(!i&&(typeof t.crs=="string"?i=dt(t.crs):"uri"in t.crs&&(i=dt(t.crs.uri)),!i))throw new Error(`Unsupported CRS: ${JSON.stringify(t.crs)}`);const s=t.orderedAxes,a=!(s?s.slice(0,2).map(f=>f.replace(/E|X|Lon/i,"e").replace(/N|Y|Lat/i,"n")).join(""):i.getAxisOrientation()).startsWith("en"),c=t.tileMatrices.sort(function(f,k){return k.cellSize-f.cellSize}),u={};for(let f=0;f<c.length;++f){const k=c[f];u[k.id]=k}const l={},d=[];if(r)for(let f=0;f<r.length;++f){const k=r[f],x=k.tileMatrix,C=u[x],N=c.indexOf(C);d[N]=x,l[x]=k}else for(let f=0;f<c.length;++f){const k=c[f].id;d.push(k)}const h=d.length,p=new Array(h),b=new Array(h),m=new Array(h),w=new Array(h),y=[-1/0,-1/0,1/0,1/0];for(let f=0;f<h;++f){const k=d[f],x=u[k],C=x.pointOfOrigin;a?p[f]=[C[1],C[0]]:p[f]=C,b[f]=x.cellSize,m[f]=[x.matrixWidth,x.matrixHeight],w[f]=[x.tileWidth,x.tileHeight];const N=l[k];if(N){const M=x.cellSize*x.tileWidth,ot=p[f][0]+N.minTileCol*M,q=p[f][0]+(N.maxTileCol+1)*M,tt=x.cellSize*x.tileHeight,qt=x.cornerOfOrigin==="bottomLeft";let at,ct;qt?(at=p[f][1]+N.minTileRow*tt,ct=p[f][1]+(N.maxTileRow+1)*tt):(at=p[f][1]-(N.maxTileRow+1)*tt,ct=p[f][1]-N.minTileRow*tt),ne(y,[ot,at,q,ct],y)}}return{grid:new gt({origins:p,resolutions:b,sizes:m,tileSizes:w,extent:r?y:void 0,matrixIds:d}),projection:i}}const Qe=["d35379db-88df-4056-af3a-620245f8e347","f17cb550-5864-4468-aeb7-f3180cfb622f","689b58e2-cf7b-45e0-9fff-9cfc0883d6b4"];class cn extends ae{constructor(t){super({state:"loading",tileGrid:null,projection:t.projection||null,transition:t.transition,wrapX:t.wrapX}),this.url_=t.url,this.group_=t.group,this.error_=null,this.root_=null,this.consolidatedMetadata_=null,this.bands_=t.bands,this.bandsByLevel_=null,this.fillValue_,this.resampleMethod_=t.resample||"linear",this.bandCount=this.bands_.length,this.setLoader(this.loadTile_.bind(this)),this.tileGrid,this.configure_().then(()=>{this.setState("ready")}).catch(n=>{this.error_=n,this.setState("error")})}async configure_(){const t=new ce(this.url_);this.root_=await O(t,{kind:"group"});try{this.consolidatedMetadata_=JSON.parse(new TextDecoder().decode(await t.get(this.root_.resolve("zarr.json").path))).consolidated_metadata.metadata}catch{}const r=(await O(this.root_.resolve(this.group_),{kind:"group"})).attrs;if("zarr_conventions"in r&&Array.isArray(r.zarr_conventions)&&Qe.every(s=>r.zarr_conventions.find(o=>o.uuid===s))&&"layout"in r.multiscales){const{tileGrid:s,projection:o,bandsByLevel:a,fillValue:c}=qe(r,this.consolidatedMetadata_,this.group_,this.bands_);this.bandsByLevel_=a,this.tileGrid=s,this.projection=o,this.fillValue_=c}else if("tile_matrix_set"in r.multiscales){const{tileGrid:s,projection:o}=tn(r);this.tileGrid=s,this.projection=o}const i=this.tileGrid.getExtent();setTimeout(()=>{this.viewResolver({showFullExtent:!0,projection:this.projection,resolutions:this.tileGrid.getResolutions(),center:ie(se(i),this.projection),extent:re(i,this.projection),zoom:1})})}async loadTile_(t,n,r,i){const s=this.tileGrid.getResolutions(),o=this.tileGrid.getResolution(t),a=this.tileGrid.getTileCoordExtent([t,n,r]),c=[],u=[];for(const p of this.bands_){let b,m,w=0;if(!this.bandsByLevel_)b=this.tileGrid.getMatrixId(t),m=o,w=t;else for(let M=0;M<s.length;M+=1){const ot=s[M];if(b&&ot<o)break;const q=this.tileGrid.getMatrixId(M);this.bandsByLevel_[q].includes(p)&&(b=q,m=this.tileGrid.getResolution(M),w=M)}if(!b||!m)throw new Error(`Could not find available resolution for band ${p}`);const y=this.tileGrid.getOrigin(w),v=Math.round((a[0]-y[0])/m),f=Math.round((a[2]-y[0])/m),k=Math.round((y[1]-a[3])/m),x=Math.round((y[1]-a[1])/m),C=`${this.group_}/${b}/${p}`,N=await O(this.root_.resolve(C),{kind:"array"});c.push(We(N,[it(k,x),it(v,f)])),u.push(m)}const l=await Promise.all(c),[d,h]=oe(this.tileGrid.getTileSize(t));return en(l,u,d,h,o,this.resampleMethod_,this.fillValue_||0)}}function qe(e,t,n,r){const i=e.multiscales,s=e["spatial:bbox"],o=dt(e["proj:code"]),a=[],c=t?{}:null;let u;for(const d of i.layout){const h=d["spatial:transform"],p=h[0],b=[h[2],h[5]],m=d.asset;if(a.push({matrixId:m,resolution:p,origin:b}),t){const w=[];for(const y of r){const v=t[`${n}/${m}/${y}`];v&&(w.push(y),u===void 0&&(u=v.fill_value))}c[m]=w}}return a.sort((d,h)=>h.resolution-d.resolution),{tileGrid:new gt({extent:s,origins:a.map(d=>d.origin),resolutions:a.map(d=>d.resolution),matrixIds:a.map(d=>d.matrixId)}),projection:o,bandsByLevel:c,fillValue:u}}function tn(e){const t=e.multiscales,n=t.tile_matrix_set,r=t.tile_matrix_limits,i=n.tileMatrices.length,s=new Array(i);let o=!1;for(let u=0;u<i;u+=1){const l=n.tileMatrices[u],d=l.id;(l.tileWidth>512||l.tileHeight>512)&&(o=!0),s[u]=r[d]}const a=Ke({},n,void 0,s);let c=a.grid;return o&&(c=new gt({tileSize:512,extent:c.getExtent(),origins:c.getOrigins(),resolutions:c.getResolutions(),matrixIds:c.getMatrixIds()})),{tileGrid:c,projection:a.projection}}function en(e,t,n,r,i,s,o){const a=e.length,c=new Float32Array(n*r*a);for(let u=0;u<r;u++)for(let l=0;l<n;l++)for(let d=0;d<a;++d){const h=e[d],p=h.shape[0],b=h.shape[1],m=i/t[d];let w=o;if(m===1)u<p&&l<b&&(w=h.data[u*b+l]);else{const y=u*m,v=l*m;switch(s){case"nearest":{const f=Math.round(y),k=Math.round(v);f<p&&k<b&&(w=h.data[f*b+k]);break}default:throw new Error(`Unsupported resample method: ${s}`)}}isNaN(w)&&(w=o),c[a*(u*n+l)+d]=w}return c}export{cn as G};
