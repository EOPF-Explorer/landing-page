import{aR as ye,al as Ce,am as ce,an as le,b2 as N,b1 as Re,ax as ae,ay as Se,a9 as F,k as _e,aa as me,ac as ve,ad as de,af as he,a3 as z,ap as we,aw as H,f as J,a6 as Ee,bC as Ke,W as je,p as Le,cm as Pe,aM as Fe}from"./XYZ.zMTP1uvH.js";import{C as Me}from"./Layer.BBoFQbFB.js";function V(C,e,t){if(!(t in C))return C[t]=new Set([e]),!0;const i=C[t],o=i.has(e);return o||i.add(e),!o}function Ae(C,e,t){const i=C[t];return i?i.delete(e):!1}function ue(C,e){const t=C.layerStatesArray[C.layerIndex];t.extent&&(e=J(e,H(t.extent,C.viewState.projection)));const i=t.layer.getRenderSource();if(!i.getWrapX()){const o=i.getTileGridForProjection(C.viewState.projection).getExtent();o&&(e=J(e,o))}return e}class De extends Me{constructor(e,t){super(e),t=t||{},this.extentChanged=!0,this.renderComplete=!1,this.renderedExtent_=null,this.renderedPixelRatio,this.renderedProjection=null,this.renderedTiles=[],this.renderedSourceKey_,this.renderedSourceRevision_,this.tempExtent=ye(),this.tempTileRange_=new Ce(0,0,0,0),this.tempTileCoord_=ce(0,0,0);const i=t.cacheSize!==void 0?t.cacheSize:512;this.tileCache_=new le(i),this.sourceTileCache_=null,this.maxStaleKeys=i*.5}getTileCache(){return this.tileCache_}getSourceTileCache(){return this.sourceTileCache_||(this.sourceTileCache_=new le(512)),this.sourceTileCache_}getOrCreateTile(e,t,i,o){const a=this.tileCache_,r=this.getLayer().getSource(),c=N(r,r.getKey(),e,t,i);let s;if(a.containsKey(c))s=a.get(c);else{const n=o.viewState.projection,l=r.getProjection();if(s=r.getTile(e,t,i,o.pixelRatio,n,!l||Re(l,n)?void 0:this.getSourceTileCache()),!s)return null;a.set(c,s)}return s}getTile(e,t,i,o){const a=this.getOrCreateTile(e,t,i,o);return a||null}getData(e){const t=this.frameState;if(!t)return null;const i=this.getLayer(),o=ae(t.pixelToCoordinateTransform,e.slice()),a=i.getExtent();if(a&&!Se(a,o))return null;const u=t.viewState,r=i.getRenderSource(),c=r.getTileGridForProjection(u.projection),s=r.getTilePixelRatio(t.pixelRatio);for(let n=c.getZForResolution(u.resolution);n>=c.getMinZoom();--n){const l=c.getTileCoordForCoordAndZ(o,n),d=this.getTile(n,l[1],l[2],t);if(!d||d.getState()!==F.LOADED)continue;const g=c.getOrigin(n),p=_e(c.getTileSize(n)),w=c.getResolution(n);let h;if(d instanceof me||d instanceof ve)h=d.getImage();else if(d instanceof de){if(h=he(d.getData()),!h)continue}else continue;const _=Math.floor(s*((o[0]-g[0])/w-l[1]*p[0])),M=Math.floor(s*((g[1]-o[1])/w-l[2]*p[1])),S=Math.round(s*r.getGutterForProjection(u.projection));return this.getImageData(h,_+S,M+S)}return null}prepareFrame(e){var o;this.renderedProjection?e.viewState.projection!==this.renderedProjection&&(this.tileCache_.clear(),this.renderedProjection=e.viewState.projection):this.renderedProjection=e.viewState.projection;const t=this.getLayer().getSource();if(!t)return!1;const i=t.getRevision();return this.renderedSourceRevision_?this.renderedSourceRevision_!==i&&(this.renderedSourceRevision_=i,this.renderedSourceKey_===t.getKey()&&(this.tileCache_.clear(),(o=this.sourceTileCache_)==null||o.clear())):this.renderedSourceRevision_=i,!0}enqueueTilesForNextExtent(){return!0}enqueueTiles(e,t,i,o,a){const u=e.viewState,r=this.getLayer(),c=r.getRenderSource(),s=c.getTileGridForProjection(u.projection),n=z(c);n in e.wantedTiles||(e.wantedTiles[n]={});const l=e.wantedTiles[n],d=r.getMapInternal(),g=Math.max(i-a,s.getMinZoom(),s.getZForResolution(Math.min(r.getMaxResolution(),d?d.getView().getResolutionForZoom(Math.max(r.getMinZoom(),0)):s.getResolution(0)),c.zDirection)),p=u.rotation,w=p?we(u.center,u.resolution,p,e.size):void 0;for(let h=i;h>=g;--h){const _=s.getTileRangeForExtentAndZ(t,h,this.tempTileRange_),M=s.getResolution(h);for(let S=_.minX;S<=_.maxX;++S)for(let E=_.minY;E<=_.maxY;++E){if(p&&!s.tileCoordIntersectsViewport([h,S,E],w))continue;const K=this.getTile(h,S,E,e);if(!K||!V(o,K,h))continue;const x=K.getKey();if(l[x]=!0,K.getState()===F.IDLE&&!e.tileQueue.isKeyQueued(x)){const Z=ce(h,S,E,this.tempTileCoord_);e.tileQueue.enqueue([K,n,s.getTileCoordCenter(Z),M])}}}}findStaleTile_(e,t){const i=this.tileCache_,o=e[0],a=e[1],u=e[2],r=this.getStaleKeys();for(let c=0;c<r.length;++c){const s=N(this.getLayer().getSource(),r[c],o,a,u);if(i.containsKey(s)){const n=i.peek(s);if(n.getState()===F.LOADED)return n.endTransition(z(this)),V(t,n,o),!0}}return!1}findAltTiles_(e,t,i,o){const a=e.getTileRangeForTileCoordAndZ(t,i,this.tempTileRange_);if(!a)return!1;let u=!0;const r=this.tileCache_,c=this.getLayer().getRenderSource(),s=c.getKey();for(let n=a.minX;n<=a.maxX;++n)for(let l=a.minY;l<=a.maxY;++l){const d=N(c,s,i,n,l);let g=!1;if(r.containsKey(d)){const p=r.peek(d);p.getState()===F.LOADED&&(V(o,p,i),g=!0)}g||(u=!1)}return u}renderFrame(e,t){this.renderComplete=!0;const i=e.layerStatesArray[e.layerIndex],o=e.viewState,a=o.projection,u=o.resolution,r=o.center,c=e.pixelRatio,s=this.getLayer(),n=s.getSource(),l=n.getTileGridForProjection(a),d=l.getZForResolution(u,n.zDirection),g=l.getResolution(d),p=n.getKey();this.renderedSourceKey_?this.renderedSourceKey_!==p&&(this.prependStaleKey(this.renderedSourceKey_),this.renderedSourceKey_=p):this.renderedSourceKey_=p;let w=e.extent;const h=n.getTilePixelRatio(c);this.prepareContainer(e,t);const _=this.context.canvas.width,M=this.context.canvas.height,S=i.extent&&H(i.extent);S&&(w=J(w,H(i.extent)));const E=g*_/2/h,K=g*M/2/h,A=[r[0]-E,r[1]-K,r[0]+E,r[1]+K],x={};this.renderedTiles.length=0;const Z=s.getPreload();if(e.nextExtent&&this.enqueueTilesForNextExtent()){const f=l.getZForResolution(o.nextResolution,n.zDirection),y=ue(e,e.nextExtent);this.enqueueTiles(e,y,f,x,Z)}const $=ue(e,w);if(this.enqueueTiles(e,$,d,x,0),Z>0&&setTimeout(()=>{this.enqueueTiles(e,$,d-1,x,Z-1)},0),!(d in x))return this.container;const ee=z(this),ge=e.time;for(const f of x[d]){const y=f.getState();if(y===F.EMPTY)continue;const j=f.tileCoord;if(y===F.LOADED&&f.getAlpha(ee,ge)===1){f.endTransition(ee);continue}if(y!==F.ERROR&&(this.renderComplete=!1),this.findStaleTile_(j,x)){Ae(x,f,d),e.animate=!0;continue}if(this.findAltTiles_(l,j,d+1,x))continue;const I=l.getMinZoom();for(let v=d-1;v>=I&&!this.findAltTiles_(l,j,v,x);--v);}const b=g/u*c/h,T=this.getRenderContext(e);Ee(this.tempTransform,_/2,M/2,b,b,0,-_/2,-M/2),i.extent&&this.clipUnrotated(T,e,S),n.getInterpolate()||(T.imageSmoothingEnabled=!1),this.preRender(T,e);const k=Object.keys(x).map(Number);k.sort(Ke);let m;const B=[],te=[];for(let f=k.length-1;f>=0;--f){const y=k[f],j=n.getTilePixelSize(y,c,a),D=l.getResolution(y)/g,I=j[0]*D*b,v=j[1]*D*b,G=l.getTileCoordForCoordAndZ(je(A),y),ie=l.getTileCoordExtent(G),q=ae(this.tempTransform,[h*(ie[0]-A[0])/g,h*(A[3]-ie[3])/g]),Te=h*n.getGutterForProjection(a);for(const O of x[y]){if(O.getState()!==F.LOADED)continue;const ne=O.tileCoord,oe=G[1]-ne[1],pe=Math.round(q[0]-(oe-1)*I),se=G[2]-ne[2],xe=Math.round(q[1]-(se-1)*v),L=Math.round(q[0]-oe*I),P=Math.round(q[1]-se*v),U=pe-L,X=xe-P,re=k.length===1;let W=!1;m=[L,P,L+U,P,L+U,P+X,L,P+X];for(let Y=0,fe=B.length;Y<fe;++Y)if(!re&&y<te[Y]){const R=B[Y];Le([L,P,L+U,P+X],[R[0],R[3],R[4],R[7]])&&(W||(T.save(),W=!0),T.beginPath(),T.moveTo(m[0],m[1]),T.lineTo(m[2],m[3]),T.lineTo(m[4],m[5]),T.lineTo(m[6],m[7]),T.moveTo(R[6],R[7]),T.lineTo(R[4],R[5]),T.lineTo(R[2],R[3]),T.lineTo(R[0],R[1]),T.clip())}B.push(m),te.push(y),this.drawTile(O,e,L,P,U,X,Te,re),W&&T.restore(),this.renderedTiles.unshift(O),this.updateUsedTiles(e.usedTiles,n,O)}}if(this.renderedResolution=g,this.extentChanged=!this.renderedExtent_||!Pe(this.renderedExtent_,A),this.renderedExtent_=A,this.renderedPixelRatio=c,this.postRender(this.context,e),i.extent&&T.restore(),T.imageSmoothingEnabled=!0,this.renderComplete){const f=(y,j)=>{var v;const Q=z(n),D=j.wantedTiles[Q],I=D?Object.keys(D).length:0;this.updateCacheSize(I),this.tileCache_.expireCache(),(v=this.sourceTileCache_)==null||v.expireCache()};e.postRenderFunctions.push(f)}return this.container}updateCacheSize(e){this.tileCache_.highWaterMark=Math.max(this.tileCache_.highWaterMark,e*2)}drawTile(e,t,i,o,a,u,r,c){let s;if(e instanceof de){if(s=he(e.getData()),!s)throw new Error("Rendering array data is not yet supported")}else s=this.getTileImage(e);if(!s)return;const n=this.getRenderContext(t),l=z(this),d=t.layerStatesArray[t.layerIndex],g=d.opacity*(c?e.getAlpha(l,t.time):1),p=g!==n.globalAlpha;p&&(n.save(),n.globalAlpha=g),n.drawImage(s,r,r,s.width-2*r,s.height-2*r,i,o,a,u),p&&n.restore(),g!==d.opacity?t.animate=!0:c&&e.endTransition(l)}getImage(){const e=this.context;return e?e.canvas:null}getTileImage(e){return e.getImage()}updateUsedTiles(e,t,i){const o=z(t);o in e||(e[o]={}),e[o][i.getKey()]=!0}}class Ze extends Fe{constructor(e){super(e)}createRenderer(){return new De(this,{cacheSize:this.getCacheSize()})}}export{De as C,Ze as T};
